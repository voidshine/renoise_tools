require(_clibroot.."cString")class'cSandbox'cSandbox.UNTRUSTED={"collectgarbage","coroutine","dofile","io","load","loadfile","module","os","setfenv","class","rawset","rawget"}function cSandbox:__init()self.callback=nil;self.str_prefix=""self.str_suffix="return"self.compile_at_once=true;self.callback_str=property(self.get_callback_str,self.set_callback_str)self.callback_str_observable=renoise.Document.ObservableString("")self.properties=property(self.get_properties,self.set_properties)self._properties={}self.modified_observable=renoise.Document.ObservableBang()self.env=nil;local a={assert=_G.assert,error=_G.error,ipairs=_G.ipairs,loadstring=_G.loadstring,math=_G.math,next=_G.next,pairs=_G.pairs,print=_G.print,pcall=_G.pcall,select=_G.select,string=_G.string,table=_G.table,tonumber=_G.tonumber,tostring=_G.tostring,type=_G.type,unpack=_G.unpack,ripairs=_G.ripairs,rprint=_G.rprint,oprint=_G.oprint}self.env=a;a={}setmetatable(self.env,{__index=function(b,c)if table.find(cSandbox.UNTRUSTED,c)then error("Property or method is not allowed:"..c)else if self.properties[c]and self.properties[c].access then return self.properties[c].access(a)else return a[c]end end end,__newindex=function(b,c,d)if self.properties[c]and self.properties[c].assign then self.properties[c].assign(a,d)else a[c]=d end end,__metatable=false})end;function cSandbox:get_callback_str()return self.callback_str_observable.value end;function cSandbox:set_callback_str(e)TRACE("cSandbox:set_callback_str(str_fn)",#e)assert(type(e)=="string","Expected string as parameter")local f=e~=self.callback_str_observable.value;local g=self:prepare_callback(e)local h,i=self:test_syntax(g)self.callback_str_observable.value=e;if not i and self.compile_at_once then local h,i=self:compile()if not h then LOG(i)end else LOG(i)end;if f then self.modified_observable:bang()end end;function cSandbox:get_properties()return self._properties end;function cSandbox:set_properties(j)assert(type(j)=="table","Expected table as parameter")self._properties=j end;function cSandbox:prepare_callback(e)assert(type(e)=="string","Expected string as parameter")local g=[[return function(...)
  ]]..self.str_prefix..[[
  ]].."\n"..e.."\n"..[[
  ]]..self.str_suffix..[[
  end]]return g end;function cSandbox:compile()if self.callback_str==""then return true,"cSandbox: no function was provided"end;local g=self:prepare_callback(self.callback_str)local k,i=loadstring(g)if not k then return false,i end;self.callback=k()setfenv(self.callback,self.env)return true end;function cSandbox.contains_comment_blocks(l)TRACE("cSandbox.contains_comment_blocks(str)")if string.find(l,"%[%[")then return true elseif string.find(l,"%]%]")then return true else return false end end;function cSandbox:test_syntax(e)TRACE("cSandbox:test_syntax(str_fn)",e)local function m()assert(loadstring(e))end;setfenv(m,self.env)local n,i=pcall(m)if not n then return false,i end;return true end;function cSandbox.strip_comments(e)TRACE("cSandbox.strip_comments(str_fn)",e)local b=cString.split(e,"\n")for c,d in ripairs(b)do local o=cString.trim(d)if o:sub(0,2)=="--"then table.remove(b,c)end end;return table.concat(b,"\n")end;function cSandbox.contains_code(e)TRACE("cSandbox.contains_code(str_fn)",e)return string.match(cSandbox.strip_comments(e),"%a")and true or false end;function cSandbox.insert_return(e)TRACE("cSandbox.insert_return(str_fn)",e)local p=false;local b=cString.split(e,"\n")for c,d in ipairs(b)do if not p then local o=cString.trim(d)if o~=""then if o:sub(0,2)~="--"then if o~="-"then p=true;if o:sub(0,6)~="return"then b[c]=("return %s"):format(o)end end end end end end;return table.concat(b,"\n")end;function cSandbox.rename_string_token(e,q,r,s)local t=s and s..q or q;local u=s and s..r or r;local v="(.?)("..t..")([^%w])"e=string.gsub(e,v,function(...)local w,x,y=select(1,...),select(2,...),select(3,...)local z="[%w_]"if string.match(w,z)or string.match(y,z)then return w..x..y end;return w..u..y end)return e end