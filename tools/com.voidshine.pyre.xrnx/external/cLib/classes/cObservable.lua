class'cObservable'cObservable.SONG={artist_observable={type="string"},name_observable={type="string"},comments_observable={type="table",subclass="string"},show_comments_after_loading_observable={type="boolean"},instruments_observable={type="table",subclass="Instrument"},patterns_observable={type="table",subclass="Pattern"},tracks_observable={type="table",subclass="Track"},selected_instrument_observable={type="table",subclass="Instrument"},selected_instrument_index_observable={type="number",subclass="integer",min=1},selected_phrase_observable={type="table",subclass="InstrumentPhrase"},selected_phrase_index_observable={type="number",subclass="integer",min=0},selected_sample_observable={type="Sample"},selected_sample_modulation_set_observable={type="SampleModulationSet"},selected_sample_device_chain_observable={type="SampleDeviceChain"},selected_sample_device_observable={type="AudioDevice"},selected_track_observable={type="Track"},selected_track_index_observable={type="number",subclass="integer",min=1},selected_track_device_observable={type="AudioDevice"},selected_parameter_observable={type="DeviceParameter"},selected_automation_parameter_observable={type="DeviceParameter"},selected_automation_device_observable={type="AudioDevice"},selected_pattern_observable={type="Pattern"},selected_pattern_index_observable={type="number",subclass="integer",min=1},selected_pattern_track_observable={type="PatternTrack"},selected_sequence_index_observable={type="number",subclass="integer",min=1},selected_note_column_observable={type="NoteColumn"},transport={playing_observable={type="boolean"},bpm_observable={type="number",subclass="float",min=32,max=999},lpb_observable={type="number",subclass="integer",min=1,max=256},tpl_observable={type="number",subclass="integer",min=1,max=16},loop_pattern_observable={type="boolean"},edit_mode_observable={type="boolean"},edit_step_observable={type="number",subclass="integer",min=0,max=64},octave_observable={subclass="integer",min=0,max=8},metronome_enabled_observable={type="boolean"},metronome_beats_per_bar_observable={type="number",subclass="integer",min=1,max=16},metronome_lines_per_beat_observable={type="number",subclass="integer",min=0,max=256},metronome_precount_enabled_observable={type="boolean"},metronome_precount_bars_observable={type="number",subclass="integer",min=1,max=4},record_quantize_enabled_observable={type="boolean"},record_quantize_lines_observable={type="number",subclass="integer",min=1,max=32},record_parameter_mode_observable={enum={renoise.Transport.RECORD_PARAMETER_MODE_PATTERN,renoise.Transport.RECORD_PARAMETER_MODE_AUTOMATION}},follow_player_observable={type="boolean"},wrapped_pattern_edit_observable={type="boolean"},single_track_edit_mode_observable={type="boolean"},groove_enabled_observable={type="boolean"},track_headroom_observable={type="number",subclass="decibel"},keyboard_velocity_enabled_observable={type="boolean"},keyboard_velocity_observable={type="number",subclass="integer",min=0,max=127}},sequencer={keep_sequence_sorted_observable={type="boolean"},selection_range_observable={type="table"},pattern_sequence_observable={type="table",subclass="integer"},pattern_assignments_observable={type="Observable"},pattern_slot_mutes_observable={type="Observable"}}}cObservable.SONG_BY_TYPE={}cObservable.MODE={MANUAL=1,AUTOMATIC=2}cObservable.mode=cObservable.MODE.MANUAL;function cObservable.set_mode(a)if cObservable.mode~=a and cObservable.mode==cObservable.MODE.AUTOMATIC then end;if a==cObservable.MODE.AUTOMATIC then end end;function cObservable.get_by_type(b,c)if cObservable.SONG_BY_TYPE[b]then return cObservable.SONG_BY_TYPE[b]end;if not c then c=cObservable.SONG end;local d={}for e,f in pairs(c)do if type(f)=="table"then if type(f.type)~="nil"and f.type==b then d[e]=f else d[e]=cObservable.get_by_type(b,f)end end end;return not table.is_empty(d)and d or nil end;cObservable.SONG_BY_TYPE["boolean"]=cObservable.get_by_type("boolean")cObservable.SONG_BY_TYPE["number"]=cObservable.get_by_type("number")cObservable.SONG_BY_TYPE["string"]=cObservable.get_by_type("string")function cObservable.get_by_type_and_name(b,g,h)if h then local i,j=string.find(g,'^'..h)if i and j then g=string.sub(g,j+1)end end;local k=cObservable.get_by_type(b)local l=cString.split(g,"%.")local m=k[l[1]]local n=m;local o=1;while m do o=o+1;m=m[l[o]]if m then n=m end end;return n or{}end;function cObservable.get_keys_by_type(b,p,q)if not q then q=cObservable.get_by_type(b)end;if not p then p=""end;local d={}for e,f in pairs(q)do if type(f)=="table"then if not f.type then p=p..e.."."local r=cObservable.get_keys_by_type(b,p,f)for s,t in ipairs(r)do table.insert(d,t)end else table.insert(d,p..e)end end end;return d end;function cObservable.detach(u,v,w)local x;u,x=cObservable.retrieve_observable(u)if x then return false,x end;local y,x=pcall(function()if type(v)=="function"then local z,A=v,w;if A then if u:has_notifier(z,A)then u:remove_notifier(z,A)end else if u:has_notifier(z)then u:remove_notifier(z)end end elseif type(w)=="function"then local A,z=v,w;if u:has_notifier(A,z)then u:remove_notifier(A,z)end else error("Unsupported arguments")end end)return y,x end;function cObservable.attach(u,v,w)local x=nil;u,x=cObservable.retrieve_observable(u)if x then return false,x end;cObservable.detach(u,v,w)if type(v)=="function"then local z,A=v,w;if A then u:add_notifier(z,A)else u:add_notifier(z)end elseif type(w)=="function"then local A,z=v,w;u:add_notifier(A,z)else error("Unsupported arguments")end;return true end;function cObservable.retrieve_observable(u)local x;if type(u)=="string"then u,x=cLib.parse_str(u)if x then return false,x end end;return u end;function cObservable.list_remove(u,B)TRACE("cObservable.list_remove",u,B)for e=1,#u do if u[e]and B==u[e].value then u:remove(e)end end;return u end;function cObservable.list_add(u,B)TRACE("cObservable.list_add",u,B)local C=false;for e=1,#u do if u[e]and B==u[e].value then C=true end end;if not C then u:insert(B)end;return u end;function cObservable.get_song_names(p)local D={}local E={"transport","sequencer"}if not p then p="rns."end;for e,f in pairs(cObservable.SONG)do if not table.find(E,e)then table.insert(D,p..e)end end;for e,f in pairs(E)do for s,t in pairs(cObservable.SONG[f])do table.insert(D,p..f.."."..s)end end;table.sort(D)return D end