require(_clibroot.."cReflection")class'cDocument'function cDocument:import(a)assert(type(a)=="string")local b=cDocument.deserialize(a,self.DOC_PROPS)for c,d in pairs(b)do self[c]=d end end;function cDocument:export()local b=cDocument.serialize(self,self.DOC_PROPS)return cLib.serialize_table(b)end;function cDocument.serialize(e,f)assert(type(f)=="table")local b={}for c,d in pairs(f)do local g=f[c]if g then b[c]=cReflection.cast_value(e[c],g)else b[c]=e[c]end end;return b end;function cDocument.deserialize(a,f)assert(type(a)=="string")assert(type(f)=="table")local b=loadstring("return "..a)local h=b()if not h then return end;b={}for c,d in pairs(f)do if h[c]then local g=d;if g then b[c]=cReflection.cast_value(h[c],g)else b[c]=h[c]end end end;return b end;function cDocument.get_property(f,i)TRACE("cDocument.get_property(props,key)",f,i)assert(type(i)=="string")assert(type(f)=="table")for c,d in ipairs(f)do if d.name==i then return d,c end end end;function cDocument.apply_value(e,j,k)TRACE("cDocument.apply_value(obj,prop,val)",e,j,k)assert(type(j)=="table")if type(j.value_default)=="boolean"then elseif type(j.value_default)=="string"then elseif type(j.value_default)=="number"then if j.value_max and j.value_min then if k>j.value_max then LOG("Clamp to range")k=j.value_max elseif k<j.value_min then LOG("Clamp to range")k=j.value_min end end;if j.zero_based then k=k+1 end else error("Unsupported value type")end;if not(e[j.name]==k)then e[j.name]=k;return k end end