local setmetatable,tonumber,tostring=setmetatable,tonumber,tostring;local a,b=math.floor,math.huge;local c,d=math.mininteger or nil,math.tointeger or nil;local e,f,g,h,i,j=string.byte,string.char,string.find,string.gsub,string.match,string.sub;local function k(l,m)error("parse error at "..l..": "..m,2)end;local n;if _VERSION=="Lua 5.1"then n='[^\32-\255]'else n='[\0-\31]'end;local type,unpack=type,table.unpack or unpack;local o=io.open;local p=nil;local function q()end;local function r(s,t)local u,v,w;local x,l,y=0,1,0;local z,A;if type(s)=='string'then u=s;x=#u;v=function()u=''x=0;v=q end else v=function()y=y+x;l=1;repeat u=s()if not u then u=''x=0;v=q;return end;x=#u until x>0 end;v()end;local B=t.startobject or q;local C=t.key or q;local D=t.endobject or q;local E=t.startarray or q;local F=t.endarray or q;local G=t.string or q;local H=t.number or q;local I=t.boolean or q;local J=t.null or q;local function K()local L=e(u,l)if not L then v()L=e(u,l)end;return L end;local function M(m)return k(y+l,m)end;local function N()return K()or M("unexpected termination")end;local function O()while true do l=i(u,'^[ \n\r\t]*()',l)if l<=x then return end;if x==0 then M("unexpected termination")end;v()end end;local function P()M('invalid value')end;local function Q(R,S,T,U)for V=1,S do local L=N()if e(R,V)~=L then M("invalid char")end;l=l+1 end;return U(T)end;local function W()if j(u,l,l+2)=='ull'then l=l+3;return J(nil)end;return Q('ull',3,nil,J)end;local function X()if j(u,l,l+3)=='alse'then l=l+4;return I(false)end;return Q('alse',4,false,I)end;local function Y()if j(u,l,l+2)=='rue'then l=l+3;return I(true)end;return Q('rue',3,true,I)end;local Z=i(tostring(0.5),'[^0-9]')local _=tonumber;if Z~='.'then if g(Z,'%W')then Z='%'..Z end;_=function(a0)return tonumber(h(a0,'.',Z))end end;local function a1()return M('invalid number')end;local function a2(a3)local a4={}local V=1;local a5=true;local L=e(u,l)l=l+1;local function a6()a4[V]=L;V=V+1;L=K()l=l+1 end;if L==0x30 then a6()if L and 0x30<=L and L<0x3A then a1()end else repeat a6()until not(L and 0x30<=L and L<0x3A)end;if L==0x2E then a5=false;a6()if not(L and 0x30<=L and L<0x3A)then a1()end;repeat a6()until not(L and 0x30<=L and L<0x3A)end;if L==0x45 or L==0x65 then a5=false;a6()if L==0x2B or L==0x2D then a6()end;if not(L and 0x30<=L and L<0x3A)then a1()end;repeat a6()until not(L and 0x30<=L and L<0x3A)end;if L and(0x41<=L and L<=0x5B or 0x61<=L and L<=0x7B or L==0x2B or L==0x2D or L==0x2E)then a1()end;l=l-1;local a7=f(unpack(a4))a7=_(a7)if a3 then a7=-a7;if a7==c and a5 then a7=c end end;return H(a7)end;local function a8(a3)local a7,L=i(u,'^(%.?[0-9]*)([-+.A-Za-z]?)',l)if a7==''then if l>x then l=l-1;return a2(a3)end;if L==''then if a3 then return H(-0.0)end;return H(0)end;if L=='e'or L=='E'then a7,L=i(u,'^([^eE]*[eE][-+]?[0-9]+)([-+.A-Za-z]?)',l)if L==''then l=l+#a7;if l>x then l=l-#a7-1;return a2(a3)end;if a3 then return H(-0.0)end;return H(0.0)end end;l=l-1;return a2(a3)end;if e(a7)~=0x2E or e(a7,-1)==0x2E then l=l-1;return a2(a3)end;if L~=''then if L=='e'or L=='E'then a7,L=i(u,'^([^eE]*[eE][-+]?[0-9]+)([-+.A-Za-z]?)',l)end;if L~=''then l=l-1;return a2(a3)end end;l=l+#a7;if l>x then l=l-#a7-1;return a2(a3)end;L=_(a7)if a3 then L=-L end;return H(L)end;local function a9(a3)l=l-1;local a7,L=i(u,'^([0-9]+%.?[0-9]*)([-+.A-Za-z]?)',l)if e(a7,-1)==0x2E then return a2(a3)end;if L~=''then if L~='e'and L~='E'then return a2(a3)end;a7,L=i(u,'^([^eE]*[eE][-+]?[0-9]+)([-+.A-Za-z]?)',l)if not a7 or L~=''then return a2(a3)end end;l=l+#a7;if l>x then l=l-#a7;return a2(a3)end;L=_(a7)if a3 then L=-L;if L==c and not g(a7,'[^0-9]')then L=c end end;return H(L)end;local function aa()local L=e(u,l)or N()if L then l=l+1;if L>0x30 then if L<0x3A then return a9(true)end else if L>0x2F then return a8(true)end end end;M("invalid number")end;local ab={0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,b,b,b,b,b,b,b,0xA,0xB,0xC,0xD,0xE,0xF,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,0xA,0xB,0xC,0xD,0xE,0xF,__index=function()return b end}setmetatable(ab,ab)local ac={['"']='"',['\\']='\\',['/']='/',['b']='\b',['f']='\f',['n']='\n',['r']='\r',['t']='\t',__index=function()M("invalid escape sequence")end}setmetatable(ac,ac)local function ad()return M("1st surrogate pair byte not continued by 2nd")end;local ae=0;local function af(ag,ah)if ag=='u'then local ai,aj,ak,al,am=e(ah,1,5)ah=ab[ai-47]*0x1000+ab[aj-47]*0x100+ab[ak-47]*0x10+ab[al-47]if ah~=b then if ah<0x80 then if am then return f(ah,am)end;return f(ah)elseif ah<0x800 then ai=a(ah/0x40)aj=ah-ai*0x40;ai=ai+0xC0;aj=aj+0x80;if am then return f(ai,aj,am)end;return f(ai,aj)elseif ah<0xD800 or 0xE000<=ah then ai=a(ah/0x1000)ah=ah-ai*0x1000;aj=a(ah/0x40)ak=ah-aj*0x40;ai=ai+0xE0;aj=aj+0x80;ak=ak+0x80;if am then return f(ai,aj,ak,am)end;return f(ai,aj,ak)elseif 0xD800<=ah and ah<0xDC00 then if ae==0 then ae=ah;if not am then return''end;ad()end;ae=0;ad()else if ae~=0 then ah=0x10000+(ae-0xD800)*0x400+ah-0xDC00;ae=0;ai=a(ah/0x40000)ah=ah-ai*0x40000;aj=a(ah/0x1000)ah=ah-aj*0x1000;ak=a(ah/0x40)al=ah-ak*0x40;ai=ai+0xF0;aj=aj+0x80;ak=ak+0x80;al=al+0x80;if am then return f(ai,aj,ak,al,am)end;return f(ai,aj,ak,al)end;M("2nd surrogate pair byte appeared without 1st")end end;M("invalid unicode codepoint literal")end;if ae~=0 then ae=0;ad()end;return ac[ag]..ah end;local function an(ao)local ap=l;local aq;local ar=''local as;while true do while true do aq=g(u,'[\\"]',ap)if aq then break end;ar=ar..j(u,l,x)if ap==x+2 then ap=2 else ap=1 end;v()if x==0 then M("unterminated string")end end;if e(u,aq)==0x22 then break end;ap=aq+2;as=true end;ar=ar..j(u,l,aq-1)l=aq+1;if g(ar,n)then M("unescaped control string")end;if as then ar=h(ar,'\\(.)([^\\]?[^\\]?[^\\]?[^\\]?[^\\]?)',af)if ae~=0 then ae=0;M("1st surrogate pair byte not continued by 2nd")end end;if ao then return C(ar)end;return G(ar)end;local function at()w=w+1;if w>1000 then M('too deeply nested json (> 1000)')end;E()O()if e(u,l)~=0x5D then local aq;while true do A=z[e(u,l)]l=l+1;A()aq=i(u,'^[ \n\r\t]*,[ \n\r\t]*()',l)if aq then l=aq else aq=i(u,'^[ \n\r\t]*%]()',l)if aq then l=aq;break end;O()local L=e(u,l)l=l+1;if L==0x2C then O()elseif L==0x5D then break else M("no closing bracket of an array")end end;if l>x then O()end end end;w=w-1;return F()end;local function au()w=w+1;if w>1000 then M('too deeply nested json (> 1000)')end;B()O()if e(u,l)~=0x7D then local aq;while true do if e(u,l)~=0x22 then M("not key")end;l=l+1;an(true)aq=i(u,'^[ \n\r\t]*:[ \n\r\t]*()',l)if aq then l=aq else O()if e(u,l)~=0x3A then M("no colon after a key")end;l=l+1;O()end;if l>x then O()end;A=z[e(u,l)]l=l+1;A()aq=i(u,'^[ \n\r\t]*,[ \n\r\t]*()',l)if aq then l=aq else aq=i(u,'^[ \n\r\t]*}()',l)if aq then l=aq;break end;O()local L=e(u,l)l=l+1;if L==0x2C then O()elseif L==0x7D then break else M("no closing bracket of an object")end end;if l>x then O()end end end;w=w-1;return D()end;z={[0]=P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,an,P,P,P,P,P,P,P,P,P,P,aa,P,P,a8,a9,a9,a9,a9,a9,a9,a9,a9,a9,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,P,at,P,P,P,P,P,P,P,P,P,P,X,P,P,P,P,P,P,P,W,P,P,P,P,P,Y,P,P,P,P,P,P,au,P,P,P,P}local function av()w=0;O()A=z[e(u,l)]l=l+1;A()end;local function aw(ax)if ax<0 then error("the argument must be non-negative")end;local ap=l-1+ax;local ar=j(u,l,ap)while ap>x and x~=0 do v()ap=ap-(x-(l-1))ar=ar..j(u,l,ap)end;if x~=0 then l=ap+1 end;return ar end;local function ay()return y+l end;return{run=av,tryc=K,read=aw,tellpos=ay}end;local function az(aA,t)local aB=o(aA)local function aC()local a0;if aB then a0=aB:read(8192)if not a0 then aB:close()aB=nil end end;return a0 end;return r(aC,t)end;return{newparser=r,newfileparser=az}