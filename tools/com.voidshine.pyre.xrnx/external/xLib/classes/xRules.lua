cLib.require(_xlibroot.."xRule")cLib.require(_xlibroot.."xRuleset")cLib.require(_xlibroot.."xMidiInput")cLib.require(_xlibroot.."xMidiMessage")cLib.require(_xlibroot.."xOscMessage")cLib.require(_xlibroot.."xOscPattern")cLib.require(_xlibroot.."xOscClient")cLib.require(_xlibroot.."xOscRouter")cLib.require(_xlibroot.."xAutomation")class'xRules'xRules.RULESET_FOLDER="./rulesets/"xRules.OUTPUT_OPTIONS={INTERNAL_AUTO="internal_auto",INTERNAL_RAW="internal_raw",EXTERNAL_MIDI="external_midi",EXTERNAL_OSC="external_osc"}function xRules:__init(...)TRACE("xRules:__init(...)",...)local a=cLib.unpack_args(...)self.active=property(self.get_active,self.set_active)self.active_observable=renoise.Document.ObservableBoolean(false)self.rulesets={}self.callback=nil;self.midi_input=xMidiInput{multibyte_enabled=a.multibyte_enabled,nrpn_enabled=a.nrpn_enabled,terminate_nrpns=a.terminate_nrpns}self.nrpn_order=a.nrpn_order or xMidiMessage.NRPN_ORDER.MSB_LSB;self.terminate_nrpns=a.terminate_nrpns_out or false;self.osc_devices=table.create()self.osc_devices_observable=renoise.Document.ObservableNumberList()self.midi_inputs={}self.midi_outputs={}self.osc_client=xOscClient()self.osc_router=xOscRouter()self.automation=xAutomation{highres_mode=true}self.osc_pattern_map={}self.ruleset_observable=renoise.Document.ObservableNumberList()self.selected_ruleset_index=property(self.get_selected_ruleset_index,self.set_selected_ruleset_index)self.selected_ruleset_index_observable=renoise.Document.ObservableNumber(0)self.selected_rule_index=property(self.get_selected_rule_index,self.set_selected_rule_index)self.selected_ruleset=property(self.get_selected_ruleset)self.selected_rule=property(self.get_selected_rule)self.aspect_handlers={}self.channel_handlers={}self.midi_input.callback_fn=function(b)self:match_message(b)end end;function xRules:get_active()return self.active_observable.value end;function xRules:set_active(c)self.active_observable.value=c end;function xRules:get_selected_ruleset_index()return self.selected_ruleset_index_observable.value end;function xRules:set_selected_ruleset_index(c)self.selected_ruleset_index_observable.value=c end;function xRules:get_selected_ruleset()return self.rulesets[self.selected_ruleset_index]end;function xRules:get_selected_rule()local d=self.selected_ruleset;if d then return d.rules[d.selected_rule_index]end end;function xRules:get_selected_rule_index()local d=self.selected_ruleset;if d then return d.selected_rule_index else return 0 end end;function xRules:set_selected_rule_index(c)local d=self.selected_ruleset;if d then d.selected_rule_index=c end end;function xRules:input_midi(e,f)TRACE("xRules:input_midi(midi_msg,port_name)",e,f)assert(type(e),"table","Expected midi_msg to be a table")assert(type(f),"string","Expected port_name to be a string")self.midi_input:input(e,f)end;function xRules:input_sysex(g,f)TRACE("xRules:input_sysex(sysex_msg,port_name)",g,f)assert(type(g),"table","Expected sysex_msg to be a table")assert(type(f),"string","Expected port_name to be a string")self:match_message(xMidiMessage{message_type=xMidiMessage.TYPE.SYSEX,values=g,port_name=f})end;function xRules:input_osc(h,i)TRACE("xRules:input_osc(osc_msg,device)",h,i)assert(type(h),"Message","Expected osc_msg to be an instance of renoise.Osc.Message")assert(type(i),"xOscDevice","Expected device to be an instance of xOscDevice")local j=self.osc_router:input(h)for k,l in ipairs(j)do if self.osc_pattern_map[l.uid]then local m=self.osc_pattern_map[l.uid]local n=self.rulesets[m.ruleset_index].rules[m.rule_index]local o={}for k,l in ipairs(h.arguments)do table.insert(o,l.value)end;local b=xOscMessage{values=o,device_name=i.name,pattern=xOscPattern(n.osc_pattern),osc_msg=h}self:match_message(b,m.ruleset_index,m.rule_index)end end end;function xRules:match_message(b,p,q,r)TRACE("xRules:match_message(xmsg,ruleset_idx,rule_idx,force_midi)",b,p,q,r)local function s(t,p)if t.active then if not t.osc_enabled and type(b)=="xOscMessage"then else t:match_message(b,p,q,r)end end end;if p then s(self.rulesets[p],p)else for k,t in ipairs(self.rulesets)do s(t,k)end end end;function xRules:transmit(u,v,p,q)TRACE("xRules:transmit(out,xmsg_in,ruleset_idx,rule_idx)",u,v,p,q)local w=renoise.song()local x=u.target;local b=u.xmsg;local y;local z,A;if x==xRules.OUTPUT_OPTIONS.INTERNAL_AUTO then z,A=self.osc_client:trigger_auto(b)y="Renoise (AUTO) ↩ "..tostring(b)elseif x==xRules.OUTPUT_OPTIONS.INTERNAL_RAW then z,A=self.osc_client:trigger_raw(b)y="Renoise (RAW) ↩ "..tostring(b)elseif x==xRules.OUTPUT_OPTIONS.EXTERNAL_MIDI then for k,B in pairs(self.midi_outputs)do if k==b.port_name then b.nrpn_order=self.nrpn_order;b.terminate_nrpns=self.terminate_nrpns;y="MIDI ↪ "..tostring(b)local C=b:create_raw_message()for D,e in ipairs(C)do B:send(e)end;z=true;break end end elseif x==xRules.OUTPUT_OPTIONS.EXTERNAL_OSC then for k,E in pairs(self.osc_devices)do if b.device_name==E.name then y="OSC ↪ "..tostring(b)z,A=E:send(b)break end end else z,A=self.osc_client:trigger_auto(b)y="Renoise (AUTO) ↩ "..tostring(b)end;if not z then return false,A end;if self.callback then self.callback(v,p,q,y)end end;function xRules:remove_osc_patterns(p,q)TRACE("xRules:remove_osc_patterns(ruleset_idx,rule_idx)",p,q)local F={}for k,l in pairs(self.osc_pattern_map)do if l.ruleset_index==p then local G;if not q then G=l.rule_index elseif not G then G=q end;if l.rule_index==G then table.insert(F,l.router_index)self.osc_pattern_map[k]=nil end end end;table.sort(F)for k,l in ripairs(F)do self.osc_router:remove_pattern(l)end;return F[1]end;function xRules:maintain_osc_pattern_map(a,H)TRACE("xRules:maintain_osc_pattern_map(args,route_idx)",a,H)for k,l in pairs(self.osc_pattern_map)do if l.rule_index>a.index then if a.type=="insert"then l.rule_index=l.rule_index+1 elseif a.type=="remove"then l.rule_index=l.rule_index-1 end end;if l.router_index>H then if a.type=="insert"then l.router_index=l.router_index+1 elseif a.type=="remove"then l.router_index=l.router_index-1 end end end end;function xRules:add_osc_patterns(p)TRACE("xRules:add_osc_patterns(ruleset_idx)",p)local t=self.rulesets[p]for k,l in ipairs(t.rules)do self:register_with_osc_router(l.osc_pattern,p,k)end end;function xRules:register_with_osc_router(I,p,q)TRACE("xRules:register_with_osc_router(osc_pattern,ruleset_idx,rule_idx)",I,p,q)local J=self.osc_router:add_pattern(I)self.osc_pattern_map[I.uid]={router_index=J,ruleset_index=p,rule_index=q}return J end;function xRules:load_ruleset(K,L)TRACE("xRules:load_ruleset(file_path,idx)",K,L)if type(K)~="string"then return false,"Expected file_path to be a string"end;if K==""then return false,"Expected file_path to be a non-empty string"end;if L and type(L)~="number"then return false,"Expected idx to be a number"elseif not L then L=#self.rulesets+1 end;local d=self:add_ruleset({},L)local M,A=d:load_definition(K)if not M then local d=self:remove_ruleset(L)return false,A end;d.modified=false;return true end;function xRules:toggle_ruleset(p)TRACE("xRules:toggle_ruleset(ruleset_idx)",p)local t=self.rulesets[p]if t then t.active=not t.active end end;function xRules:add_ruleset(N,p)TRACE("xRules:add_ruleset(ruleset_def,ruleset_idx)",N,p)assert(type(N)=="table","Expected ruleset_def to be a table")local t=xRuleset(self,N)if not p then p=#self.rulesets+1 end;if self.selected_ruleset_index==0 then self.selected_ruleset_index=1 end;table.insert(self.rulesets,p,t)self.ruleset_observable:insert(p,1)t.osc_enabled_observable:add_notifier(function()local d=self.selected_ruleset;if d and not d.suppress_notifier then local p=self.selected_ruleset_index;if d.osc_enabled then self:add_osc_patterns(p)else self:remove_osc_patterns(p)end end end)t.rules_observable:add_notifier(function(a)local H=nil;if a.type=="remove"then local p=self.selected_ruleset_index;H=self:remove_osc_patterns(p,a.index)elseif a.type=="insert"then local n=t.rules[a.index]local p=self.selected_ruleset_index;H=self:register_with_osc_router(n.osc_pattern,p,a.index)end;if H then self:maintain_osc_pattern_map(a,H)end end)t:compile()return t end;function xRules:remove_ruleset(L)TRACE("xRules:remove_ruleset(idx)",L)local t=self.rulesets[L]if not t then local A=("Could not remove ruleset with index #%d- it doesn't exist"):format(L)return false,A end;for k,l in ripairs(t.rules)do t:remove_rule(k)end;table.remove(self.rulesets,L)self.ruleset_observable:remove(L)return true end;function xRules:replace_ruleset(K,L)TRACE("xRules:replace_ruleset(file_path,idx)",K,L)assert(type(K)=="string","Expected file_path to be a string")assert(type(L)=="number","Expected idx to be a string")self:remove_ruleset(L)local M,A=self:load_ruleset(K,L)return M,A end;function xRules:save_ruleset()TRACE("xRules:save_ruleset()")local d=self.selected_ruleset;local M,A=d:save_definition()if not M then return false,A end;d.modified=false;return true end;function xRules:revert_ruleset()TRACE("xRules:revert_ruleset()")local d=self.selected_ruleset;local O=self.selected_ruleset_index;local M,A=self:replace_ruleset(d.file_path,O)if not M then return false,A end;return true end;function xRules:open_midi_input(f)TRACE("xRules:open_midi_input(port_name)",f)local P=renoise.Midi.available_input_devices()if table.find(P,f)then local Q=self.midi_inputs[f]~=nil;local R=Q and self.midi_inputs[f].is_open;if Q and R then return elseif Q and not R then self.midi_inputs[f]:close()end;self.midi_inputs[f]=renoise.Midi.create_input_device(f,function(e)if not xLib.is_song_available()or not self.active then return end;self:input_midi(e,f)end,function(g)if not xLib.is_song_available()or not self.active then return end;self:input_sysex(g,f)end)else LOG("*** Could not create MIDI input device "..f)end end;function xRules:close_midi_input(f)TRACE("xRules:close_midi_input(port_name)",f)local S=self.midi_inputs[f]if S and S.is_open then S:close()end;self.midi_inputs[f]=nil end;function xRules:open_midi_output(f)TRACE("xRules:open_midi_output(port_name)",f)local T=renoise.Midi.available_output_devices()if table.find(T,f)then self.midi_outputs[f]=renoise.Midi.create_output_device(f)else LOG("*** Could not create MIDI output device "..f)end end;function xRules:close_midi_output(f)TRACE("xRules:close_midi_output(port_name)",f)local B=self.midi_outputs[f]if B and B.is_open then B:close()end;self.midi_outputs[f]=nil end;function xRules:add_osc_device(i)TRACE("xRules:add_osc_device(device)",i)assert(type(i)=="xOscDevice","Expected xOscDevice as argument")i.callback=function(h)if not xLib.is_song_available()or not self.active then return end;self:input_osc(h,i)end;local U;for k,l in ipairs(self.osc_devices)do if l.name==i.name then U=k;break end end;if U then local V=self.osc_devices[U]self.osc_devices[U]:import(i:export())else self.osc_devices:insert(i)self.osc_devices_observable:insert(#self.osc_devices)end end;function xRules:remove_osc_device(U)TRACE("xRules:remove_osc_device(device_idx)",U)local i=self.osc_devices[U]i:close()self.osc_devices:remove(U)self.osc_devices_observable:remove(U)end;function xRules:set_osc_device_property(W,X,Y)TRACE("xRules:set_osc_device_property(device_name,key,value)",W,X,Y)for k,l in ipairs(self.osc_devices)do if l.name==W then l[X]=Y end end end;function xRules:get_unique_osc_device_name(Z,_)TRACE("xRules:get_unique_osc_device_name(str_name,count)",Z,_)local a0=function(Z)for k,l in ipairs(self.osc_devices)do if l.name==Z then return true end end end;local _=1;local a1=Z;while a0(a1)do a1=("%s (%d)"):format(Z,_)_=_+1 end;return a1 end;function xRules:get_ruleset_by_name(Z)TRACE("xRules:get_ruleset_by_name(str_name)",Z)for k,l in ipairs(self.rulesets)do if l.name==Z then return l,k end end end