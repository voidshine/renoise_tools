cLib.require(_xlibroot.."cTable")cLib.require(_xlibroot.."xPatternSelection")cLib.require(_xlibroot.."xPatternSequencer")cLib.require(_xlibroot.."xNoteColumn")class'xVoiceRunner'xVoiceRunner.COLLECT_MODE={SELECTION=1,CURSOR=2}xVoiceRunner.CONDITIONS={CREATE_VOICE_RUN=7,CREATE_ORPHAN_RUN=8,CONTINUE_VOICE_RUN=1,CONTINUE_GHOST_NOTE=9,CONTINUE_GLIDE_NOTE=10,CONTINUE_RUN_OFFED=11,CONTINUE_ORPHAN_RUN=12,SPLIT_AT_NOTE=4,SPLIT_AT_NOTE_CHANGE=5,SPLIT_AT_INSTR_CHANGE=6,STOP_AT_NOTE_OFF=2,STOP_AT_NOTE_CUT=3}xVoiceRunner.GHOST_NOTE=256;function xVoiceRunner:__init(...)TRACE("xVoiceRunner:__init(...)",...)local a=cLib.unpack_args(...)self.split_at_note=type(a.split_at_note)~="boolean"and true or a.split_at_note;self.split_at_note_change=type(a.split_at_note_change)~="boolean"and true or a.split_at_note_change;self.split_at_instrument_change=type(a.split_at_instrument_change)~="boolean"and true or a.split_at_instrument_change;self.link_ghost_notes=type(a.link_ghost_notes)~="boolean"and true or a.link_ghost_notes;self.link_ghost_notes=type(a.link_ghost_notes)~="boolean"and true or a.link_ghost_notes;self.stop_at_note_off=type(a.stop_at_note_off)~="boolean"and false or a.stop_at_note_off;self.stop_at_note_cut=type(a.stop_at_note_cut)~="boolean"and false or a.stop_at_note_cut;self.remove_orphans=type(a.remove_orphans)~="boolean"and false or a.remove_orphans;self.create_noteoffs=type(a.create_noteoffs)~="boolean"and false or a.create_noteoffs;self.close_open_notes=type(a.close_open_notes)~="boolean"and false or a.close_open_notes;self.reveal_subcolumns=type(a.reveal_subcolumns)~="boolean"and false or a.reveal_subcolumns;self.wrap_around_jump=type(a.wrap_around_jump)~="boolean"and true or a.wrap_around_jump;self.compact_columns=true;self.whitelist=nil;self.voice_columns={}self.voice_runs={}self.unique_notes={}self.low_column=nil;self.high_column=nil end;function xVoiceRunner:reset()TRACE("xVoiceRunner:reset()")self.voice_columns={}self.voice_runs={}self.unique_notes={}end;function xVoiceRunner:purge_voices()TRACE("xVoiceRunner:purge_voices()")end;function xVoiceRunner:collect(b,c,d,e,f)TRACE("xVoiceRunner:collect(ptrack_or_phrase,collect_mode,selection,trk_idx,seq_idx)",b,c,d,e,f)assert(type(b)=="PatternTrack"or type(b)=="InstrumentPhrase")assert(type(c)=="number")if b.is_empty then return end;local g=type(b)=="PatternTrack"if c==xVoiceRunner.COLLECT_MODE.CURSOR then e=rns.selected_track_index;f=rns.selected_sequence_index;local h=rns.selected_note_column_index;d=xPatternSelection.get_column_in_track(f,e,h)elseif c==xVoiceRunner.COLLECT_MODE.SELECTION then if g then assert(type(e)=="number")assert(type(f)=="number")end;assert(type(d)=="table")end;local i,j,k,l,m;if g then local n=rns.tracks[e]local o,p=xPatternSequencer.get_pattern_at_index(f)i=o.number_of_lines;j=n.visible_note_columns;k=n.volume_column_visible;l=n.panning_column_visible;m=n.delay_column_visible else i=b.number_of_lines;j=b.visible_note_columns;k=b.volume_column_visible;l=b.panning_column_visible;m=b.delay_column_visible end;local q=b:lines_in_range(d.start_line,d.end_line)for r,s in ipairs(q)do local t=r+d.start_line-1;if not s.is_empty then for h,u in ipairs(s.note_columns)do if not u.is_empty and h>j or(h<d.start_column or h>d.end_column)then else local v=false;local w=false;local x=false;local y=false;local z=nil;local A,B,C,D,E,F,G,H=self:detect_run_condition(u,h,k,l,g)local I=function()TRACE("xVoiceRunner:collect() - assign_instr_and_note")G=E and G or xVoiceRunner.GHOST_NOTE;F=B and F or nil end;local J=function()TRACE("xVoiceRunner:collect() - handle_note_off_cut")z=xNoteColumn(xNoteColumn.do_read(u))w=true;G=self.voice_columns[h].instrument_index;self.voice_columns[h]=nil end;local K=function()TRACE("xVoiceRunner:collect() - handle_offed_run")self.voice_columns[h].offed=true;G=self.voice_columns[h].instrument_index end;local L=function()TRACE("xVoiceRunner:collect() - handle_create_voice_run")I()v=true;self.voice_columns[h]={instrument_index=G,note_value=F}end;local M=function()TRACE("xVoiceRunner:collect() - handle_create_orphan_run")v=true;y=true;G=0;self.voice_columns[h]={instrument_index=G}end;local N=function()TRACE("xVoiceRunner:collect() - handle_split_at_note_or_change")I()x=not self.voice_columns[h].offed and true or false;v=true;self.voice_columns[h]={instrument_index=G,note_value=F}end;local O=function()TRACE("xVoiceRunner:collect() - handle_instrument_change")x=not self.voice_columns[h].offed and true or false;v=true;self.voice_columns[h]={instrument_index=G,note_value=F}end;local P=function()TRACE("xVoiceRunner:collect() - handle_continue_orphan_run")self.voice_columns[h]={instrument_index=G,note_value=F}end;local Q=function()TRACE("xVoiceRunner:collect() - handle_continue_voice_run")G=self.voice_columns[h].instrument_index end;local R=function()TRACE("xVoiceRunner:collect() - handle_continue_ghost_note")I()end;local S=function()TRACE("xVoiceRunner:collect() - handle_continue_glide_note")I()end;local T={[xVoiceRunner.CONDITIONS.CREATE_VOICE_RUN]=L,[xVoiceRunner.CONDITIONS.CREATE_ORPHAN_RUN]=M,[xVoiceRunner.CONDITIONS.CONTINUE_VOICE_RUN]=Q,[xVoiceRunner.CONDITIONS.CONTINUE_GHOST_NOTE]=R,[xVoiceRunner.CONDITIONS.CONTINUE_GLIDE_NOTE]=S,[xVoiceRunner.CONDITIONS.CONTINUE_RUN_OFFED]=K,[xVoiceRunner.CONDITIONS.CONTINUE_ORPHAN_RUN]=P,[xVoiceRunner.CONDITIONS.STOP_AT_NOTE_OFF]=J,[xVoiceRunner.CONDITIONS.STOP_AT_NOTE_CUT]=J,[xVoiceRunner.CONDITIONS.SPLIT_AT_NOTE]=N,[xVoiceRunner.CONDITIONS.SPLIT_AT_NOTE_CHANGE]=N,[xVoiceRunner.CONDITIONS.SPLIT_AT_INSTR_CHANGE]=O}if T[A]then T[A]()end;local U=true;if type(G)=="number"then local V,W=nil,nil;if self.voice_runs and self.voice_runs[h]then W=#self.voice_runs[h]end;if W then V=self.voice_runs[h][W]end;if V and x then V.implied_noteoff=x end;if V and v and not V.number_of_lines then local X,Y=cTable.bounds(V)V.number_of_lines=r-X end;cTable.expand(self.voice_runs,h)W=#self.voice_runs[h]+(v and 1 or 0)cTable.expand(self.voice_runs,h,W)V=self.voice_runs[h][W]V[t]=xNoteColumn.do_read(u)if w then local X,Y=cTable.bounds(V)local i=Y-X;V.number_of_lines=i;if z then V[Y]=nil end elseif v and D and self.stop_at_note_cut then V.number_of_lines=1;V.single_line_trigger=true end;if D or C then if self.voice_columns[h]then if self.stop_at_note_off and C or self.stop_at_note_cut and D then self.voice_columns[h]=nil else self.voice_columns[h].offed=true end end end;if z then V.actual_noteoff_col=z end;if y then V.orphaned=y end;if v and B and self.whitelist then if not table.find(self.whitelist,F)then V.__skip_run=true;U=false end end end;if U then if F and G then cTable.expand(self.unique_notes,F,G-1)self.unique_notes[F][G-1]=true elseif F then cTable.expand(self.unique_notes,F)end end end end end end;self.low_column,self.high_column=cTable.bounds(self.voice_runs)for h,Z in pairs(self.voice_runs)do for _,a0 in pairs(Z)do if a0.__skip_run then self.voice_runs[h][_]=nil else if self.remove_orphans and a0.orphaned then self.voice_runs[h][_]=nil;if table.is_empty(self.voice_runs[h])then table.remove(self.voice_runs,h)end else local a1,a2=cTable.bounds(a0)if not a0.number_of_lines then local a3=self.voice_columns[h]if a3 then local a4,a5,a6=xVoiceRunner.get_final_notecol_info(a0,true,k,l)if not a0.single_line_trigger and(a6 and self.stop_at_note_cut or a5 and self.stop_at_note_off)then a0.number_of_lines=1+d.end_line-a2;TRACE("xVoiceRunner:collect() - post-process, assigned length to open voice",a0.number_of_lines)else local a7=self:detect_run_length(b,h,a2,i,k,l)a0.number_of_lines=a2-a1+a7;a0.open_ended=a1+a0.number_of_lines-1>=d.end_line;TRACE("xVoiceRunner:collect() - post-process, extend length to selection boundary",a0.number_of_lines)end else a0.number_of_lines=a2-a1;TRACE("xVoiceRunner:collect() - post-process, set length",a0.number_of_lines)end else end end end;if a0.number_of_lines==0 then self.voice_runs[h][_]=nil;TRACE("xVoiceRunner:collect() - post-process, removed zero-length run")end end end;if self.compact_columns and c~=xVoiceRunner.COLLECT_MODE.CURSOR then cTable.compact(self.voice_runs)end end;function xVoiceRunner:collect_at_cursor()TRACE("xVoiceRunner:collect_at_cursor()")local b=rns.selected_pattern_track;local h=rns.selected_note_column_index;local t=rns.selected_line_index;self:reset()self:collect(b,xVoiceRunner.COLLECT_MODE.CURSOR)local a8=xVoiceRunner.in_range(self.voice_runs,t,t,{restrict_to_column=h,include_before=true,include_after=true})if a8[h]then local a9,aa=cTable.bounds(a8[h])return a8[h][a9]end end;function xVoiceRunner:collect_above_cursor()TRACE("xVoiceRunner:collect_above_cursor()")local b=rns.selected_pattern_track;local h=rns.selected_note_column_index;local t=rns.selected_line_index;self:reset()self:collect(b,xVoiceRunner.COLLECT_MODE.CURSOR)local a8=xVoiceRunner.in_range(self.voice_runs,1,t,{restrict_to_column=h,include_before=true,include_after=true})if a8[h]then local X,Y=cTable.bounds(a8[h])for r=Y,X,-1 do if a8[h][r]then local a1,a2=cTable.bounds(a8[h][r])if t>a1 then return a8[h][r]end end end end;if self.wrap_around_jump then if self.voice_runs[h]then local X,Y=cTable.bounds(self.voice_runs[h])return self.voice_runs[h][Y]end end end;function xVoiceRunner:collect_below_cursor()TRACE("xVoiceRunner:collect_below_cursor()")local b=rns.selected_pattern_track;local h=rns.selected_note_column_index;local t=rns.selected_line_index;local o,p=xPatternSequencer.get_pattern_at_index(rns.selected_sequence_index)self:reset()self:collect(b,xVoiceRunner.COLLECT_MODE.CURSOR)local a8=xVoiceRunner.in_range(self.voice_runs,t,o.number_of_lines,{restrict_to_column=h,include_before=true,include_after=true})if a8[h]then local X,Y=cTable.bounds(a8[h])for r=X,Y do if a8[h][r]then local a1,a2=cTable.bounds(a8[h][r])if t<a1 then return a8[h][r]end end end end;if self.wrap_around_jump then if self.voice_runs[h]then local X,Y=cTable.bounds(self.voice_runs[h])return self.voice_runs[h][X]end end end;function xVoiceRunner:detect_run_condition(u,h,k,l,ab)TRACE("xVoiceRunner:detect_run_condition(notecol,col_idx,vol_visible,pan_visible,from_pattern)",u,h,k,l,ab)assert(type(u)=="NoteColumn"or type(u)=="xNoteColumn")assert(type(h)=="number")assert(type(k)=="boolean")assert(type(l)=="boolean")local B,C,D,E,F,G,H=xVoiceRunner.get_notecol_info(u,true,k,l)local ac=nil;if(C or D)and not B then if self.voice_columns[h]then if self.stop_at_note_off and C then ac=xVoiceRunner.CONDITIONS.STOP_AT_NOTE_OFF elseif self.stop_at_note_cut and D then ac=xVoiceRunner.CONDITIONS.STOP_AT_NOTE_CUT else ac=xVoiceRunner.CONDITIONS.CONTINUE_RUN_OFFED end end elseif E or B then local ad=self.voice_columns[h]and F~=self.voice_columns[h].note_value or false;if not self.voice_columns[h]then ac=xVoiceRunner.CONDITIONS.CREATE_VOICE_RUN elseif B and(self.split_at_note or self.split_at_note_change and ad)then if self.link_ghost_notes and not E and ab then ac=xVoiceRunner.CONDITIONS.CONTINUE_GHOST_NOTE elseif self.link_glide_notes and H then ac=xVoiceRunner.CONDITIONS.CONTINUE_GLIDE_NOTE else if ad then ac=xVoiceRunner.CONDITIONS.SPLIT_AT_NOTE_CHANGE else ac=xVoiceRunner.CONDITIONS.SPLIT_AT_NOTE end end elseif E and self.split_at_instrument_change and G~=self.voice_columns[h].instrument_index then ac=xVoiceRunner.CONDITIONS.SPLIT_AT_INSTR_CHANGE elseif self.voice_columns[h].instrument_index==0 and not(B or E)then ac=xVoiceRunner.CONDITIONS.CREATE_ORPHAN_RUN end elseif not u.is_empty then if self.voice_columns[h]then ac=xVoiceRunner.CONDITIONS.CONTINUE_VOICE_RUN else ac=xVoiceRunner.CONDITIONS.CONTINUE_ORPHAN_RUN end end;return ac,B,C,D,E,F,G,H end;function xVoiceRunner:detect_run_length(b,h,ae,af,k,l)TRACE("xVoiceRunner:detect_run_length(ptrack_or_phrase,col_idx,start_line,end_line,vol_visible,pan_visible)",b,h,ae,af,k,l)assert(type(b)=="PatternTrack"or type(b)=="InstrumentPhrase")assert(type(h)=="number")assert(type(ae)=="number")assert(type(af)=="number")if ae>af then return 0 end;local ab=type(b)=="PatternTrack"local q=b:lines_in_range(ae,af)for r,s in ipairs(q)do if r>1 then local t=r+ae-1;if not s.is_empty then for ag,u in ipairs(s.note_columns)do if not u.is_empty and h==ag then local A=self:detect_run_condition(u,h,k,l,ab)if A==xVoiceRunner.CONDITIONS.STOP_AT_NOTE_OFF or A==xVoiceRunner.CONDITIONS.STOP_AT_NOTE_CUT or A==xVoiceRunner.CONDITIONS.SPLIT_AT_INSTR_CHANGE or A==xVoiceRunner.CONDITIONS.CREATE_VOICE_RUN then return r elseif A==xVoiceRunner.CONDITIONS.SPLIT_AT_NOTE_OR_CHANGE then return r-1 end end end end end end;return 1+af-ae end;function xVoiceRunner:resolve_notecol(h,t)TRACE("xVoiceRunner:resolve_notecol(col_idx,line_idx)",h,t)assert(type(h)=="number")assert(type(t)=="number")local _=xVoiceRunner.get_most_recent_run_index(self.voice_runs[h],t)if _ then local a0=self.voice_runs[h][_]if a0 then return a0[t],_ end end end;function xVoiceRunner:merge_columns(b,d,e,f)TRACE("xVoiceRunner:merge_columns(ptrack_or_phrase,selection,trk_idx,seq_idx)",b,d,e,f)local c=xVoiceRunner.COLLECT_MODE.SELECTION;self:collect(b,c,d,e,f)local ah={{}}local ai=nil;local aj=nil;local ak=function(a3,t)table.insert(ah[1],a3.voice_run)ai=#ah[1]aj=t end;for t=d.start_line,d.end_line do local al=xVoiceRunner.get_runs_on_line(self.voice_runs,t)for r,a3 in ipairs(al)do local u=a3.voice_run[t]if u.note_value<renoise.PatternLine.NOTE_OFF then local am,a8=xVoiceRunner.has_room(ah,t,1,a3.voice_run.number_of_lines)if not am then if aj==t then ah[1][ai]=a3.voice_run elseif aj<t then local an=ah[1][ai]local i=t-aj;ah[1][ai]=xVoiceRunner.shorten_run(an,i)ak(a3,t)end else ak(a3,t)end end end end;local ao=d.start_column;if ao>1 then repeat table.insert(ah,1,{})ao=ao-1 until ao==1 end;self.voice_runs=ah;self:write(b,d,e)self:purge_voices()end;function xVoiceRunner.shorten_run(V,i)TRACE("xVoiceRunner.shorten_run(voice_run,num_lines)",V,i)local X,Y=cTable.bounds(V)for r,ap in pairs(V)do if type(r)=="number"then if r>X+i-1 then V[r]=nil end end end;V.number_of_lines=i;return V end;function xVoiceRunner:write(b,d,e)TRACE("xVoiceRunner:write(ptrack_or_phrase,selection,trk_idx)",b,d,e)assert(type(b)=="PatternTrack"or type(b)=="InstrumentPhrase")local aq=type(b)=="PatternTrack"local k,l,m;local n=rns.tracks[e]if aq then k=n.volume_column_visible;l=n.panning_column_visible;m=n.delay_column_visible else k=b.volume_column_visible;l=b.panning_column_visible;m=b.delay_column_visible end;local ar={}local as={}local q=b:lines_in_range(d.start_line,d.end_line)for r,s in ipairs(q)do local t=r+d.start_line-1;for h,Z in pairs(self.voice_runs)do local at=h>=d.start_column and h<=d.end_column;if at then local u=s.note_columns[h]u:clear()for _,a0 in pairs(Z)do if a0[t]then local X,Y=cTable.bounds(a0)local au=xNoteColumn(a0[t])au:do_write(u)if self.create_noteoffs then ar[h]={line_index=X+a0.number_of_lines,run_index=_}end;as[h]=a0.open_ended elseif ar[h]and ar[h].line_index==t and ar[h].run_index==_ then if a0.actual_noteoff_col then a0.actual_noteoff_col:do_write(u)elseif not a0.single_line_trigger and not a0.orphaned then u.note_value=renoise.PatternLine.NOTE_OFF end;ar[h]=nil end end;if t==d.end_line then if self.close_open_notes then if as[h]then xVoiceRunner.terminate_note(u,self.reveal_subcolumns,k,l,m,n or b)end end end end end end;local av,aw=cTable.bounds(self.voice_runs)local ax;if aq then ax=rns.tracks[e]else ax=rns.selected_phrase end;if aw then ax.visible_note_columns=math.max(aw,ax.visible_note_columns)end;if aw and self.high_column then local q=b:lines_in_range(d.start_line,d.end_line)for r,s in ipairs(q)do local t=r+d.start_line-1;for h=self.high_column,aw+1,-1 do local u=s.note_columns[h]u:clear()end end end end;function xVoiceRunner.get_voice_run_selection(ay,e,h)TRACE("xVoiceRunner.get_voice_run_selection(vrun,trk_idx,col_idx)",ay,e,h)local X,Y=cTable.bounds(ay)local af=X+ay.number_of_lines-1;af=(ay.implied_noteoff and not ay.actual_noteoff_col or ay.open_ended or not ay.actual_noteoff_col or ay.single_line_trigger)and af or af+1;return{start_line=X,start_track=e,start_column=h,end_line=af,end_track=e,end_column=h}end;function xVoiceRunner.has_room(az,aA,h,i)TRACE("xVoiceRunner:has_room(voice_runs,line_start,col_idx,num_lines)",az,aA,h,i)assert(type(aA)=="number")assert(type(h)=="number")assert(type(i)=="number")local aB=aA+i-1;local a8=xVoiceRunner.in_range(az,aA,aB,{restrict_to_column=h,include_before=true,include_after=true})local am=#table.keys(a8)==0;return am,a8 end;function xVoiceRunner.in_range(az,aA,aB,a)TRACE("xVoiceRunner.in_range(voice_runs,line_start,line_end,args)",az,aA,aB,a)local aC={}if a.exclude_columns and a.restrict_to_column then LOG("*** in_range - warning: use _either_ exclude_columns or restrict_to_column, not both!")return aC end;local aD=a.matched_columns or{}local aE=a.exclude_columns or{}if a.restrict_to_column then for r=1,12 do aE[r]=r~=a.restrict_to_column and true or false end end;local aF=function(h,_)cTable.expand(aC,h)aC[h][_]=az[h][_]aD[h]=true end;for t=aA,aB do for h,Z in pairs(az)do if aE[h]then else for _,aG in pairs(Z)do if aG[t]then local aH=false;if a.include_after then aH=true else aH=aB>=t+aG.number_of_lines end;if aH then aF(h,_)break end end end end end end;if a.include_before then for h,Z in pairs(az)do if aE[h]or aD[h]then else local aI=xVoiceRunner.get_open_run(Z,aA)if aI then aF(h,aI)end end end end;return aC,aD end;function xVoiceRunner.get_runs_on_line(az,t)TRACE("xVoiceRunner.get_runs_on_line(voice_runs,line_idx)",az,t)local al={}for h,Z in pairs(az)do for _,a0 in pairs(Z)do local a1,a2=cTable.bounds(a0)if a1==t then local a3=xVoiceRunner.create_voice(a0,h,_,a1)table.insert(al,a3)end end end;return al end;function xVoiceRunner.create_voice(V,h,_,t)TRACE("xVoiceRunner.create_voice(voice_run,col_idx,run_idx,line_idx)",V,h,_,t)assert(type(V)=="table")assert(type(h)=="number")assert(type(_)=="number")assert(type(t)=="number")return{voice_run=V,col_idx=h,run_idx=_,line_idx=t}end;function xVoiceRunner.get_initial_notecol(V)TRACE("xVoiceRunner.get_initial_notecol(voice_run)",V)local a1,a2=cTable.bounds(V)return V[a1],a1 end;function xVoiceRunner.get_open_run(Z,aA)TRACE("xVoiceRunner.get_open_run(run_col,line_start)",Z,aA)local aJ=false;for _,a0 in pairs(Z)do local X,Y=cTable.bounds(a0)local af=X+a0.number_of_lines-1;if X<aA and af>=aA then return _ end end end;function xVoiceRunner.get_higher_notes_in_column(Z,F)TRACE("xVoiceRunner.get_higher_notes_in_column(run_col,note_val)",Z,xNoteColumn.note_value_to_string(F))local aK={}if not table.is_empty(Z)then for _,V in pairs(Z)do local a1,a2=cTable.bounds(V)if V[a1].note_value>F then table.insert(aK,{run_idx=_,line_idx=a1})end end end;return aK end;function xVoiceRunner.get_most_recent_run_index(Z,t)TRACE("xVoiceRunner.get_most_recent_run_index(run_col,line_idx)",Z,t)assert(type(Z)=="table")assert(type(t)=="number")local aL=nil;local aM=table.is_empty(Z)if not aM then for _,a0 in pairs(Z)do local X,Y=cTable.bounds(a0)if Y then for r=1,math.min(t,Y)do if a0[r]then aL=_ end;if aL and r==t then break end end end end end;return aL end;function xVoiceRunner.get_high_low_note_values(Z,aA,aB)TRACE("xVoiceRunner.get_high_low_note_values(run_col,line_start,line_end)",Z,aA,aB)assert(type(Z)=="table")local aN=aA and aB and true or false;local aO,aP=1000,-1000;local aJ=false;local at=false;for _,a0 in pairs(Z)do for t,aG in pairs(a0)do if type(aG)=="table"then at=aN and t>=aA and t<=aB;if aG.note_value<renoise.PatternLine.NOTE_OFF and(not aN or aN and at)then aO=math.min(aO,aG.note_value)aP=math.max(aP,aG.note_value)aJ=true end end end;if aJ and not at then break end end;if aJ then return aP,aO end end;function xVoiceRunner.get_column_start_end_line(Z)TRACE("xVoiceRunner.get_column_start_end_line(run_col)",Z)if not Z or table.is_empty(table.keys(Z))then return end;local ae,af=513,0;for _,a0 in pairs(Z)do local X,Y=cTable.bounds(Z[_])af=math.max(af,Y)ae=math.min(ae,X)end;return ae,af end;function xVoiceRunner.get_final_notecol_info(V,aQ,k,l)TRACE("xVoiceRunner.get_final_notecol_info(voice_run,respect_visibility,vol_visible,pan_visible)",V,aQ,k,l)local X,Y=cTable.bounds(V)return xVoiceRunner.get_notecol_info(V[Y],aQ,k,l)end;function xVoiceRunner.get_notecol_info(u,aQ,k,l)TRACE("xVoiceRunner.get_notecol_info(notecol,respect_visibility,vol_visible,pan_visible)",u,aQ,k,l)local E=u.instrument_value<255;local F=u.note_value<renoise.PatternLine.NOTE_OFF and u.note_value or nil;local G=E and u.instrument_value+1 or nil;local B=u.note_value<renoise.PatternLine.NOTE_OFF;local C=u.note_value==renoise.PatternLine.NOTE_OFF;local D=false;local aR=string.sub(u.volume_string,0,1)=="C"local aS=string.sub(u.panning_string,0,1)=="C"if aQ then if aR then D=k elseif aS then D=l end else D=aR or aS end;local H=false;local aT=string.sub(u.volume_string,0,1)=="G"local aU=string.sub(u.panning_string,0,1)=="G"if aQ then if aT then H=k elseif aU then H=l end else H=aT or aU end;return B,C,D,E,F,G,H end;function xVoiceRunner.terminate_note(u,aV,k,l,m,ax)TRACE("xVoiceRunner.terminate_note(notecol,reveal_subcolumns,vol_visible,pan_visible,dly_visible,track_or_phrase)",u,aV,k,l,m,ax)local aW=rns.transport.tpl-1;local aX=("C%X"):format(aW)local B,C,D=xVoiceRunner.get_notecol_info(u,true,k,l)if C or D then elseif B then if u.panning_value==255 then u.panning_string=aX;l=true elseif u.volume_value==255 then u.volume_string=aX;k=true end else u.note_value=renoise.PatternLine.NOTE_OFF;u.delay_value=255;m=true end;if aV then ax.volume_column_visible=k;ax.panning_column_visible=l;ax.delay_column_visible=m end end