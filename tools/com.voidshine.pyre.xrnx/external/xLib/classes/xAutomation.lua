cLib.require(_xlibroot.."xPlayPos")cLib.require(_xlibroot.."xStreamPos")class'xAutomation'xAutomation.FOLLOW_MODE={AUTOMATIC="automatic",EDIT_POS="edit_pos",PLAY_POS="play_pos"}xAutomation.WRITE_MODE={INTERLEAVE="interleave",PUNCH_IN="punch_in"}xAutomation.PLAYMODE={AUTOMATIC=0,POINTS=1,LINEAR=2,CUBIC=3}xAutomation.PLAYMODE_NAMES={"Automatic","Points","Linear","Cubic"}function xAutomation:__init(...)local a=cLib.unpack_args(...)self.follow_mode=a.follow_mode or xAutomation.FOLLOW_MODE.AUTOMATIC;self.write_mode=a.write_mode or xAutomation.WRITE_MODE.PUNCH_IN;self.playmode=a.playmode or xAutomation.PLAYMODE.AUTOMATIC;self.highres_mode=a.highres_mode or false;renoise.tool().app_new_document_observable:add_notifier(function()rns=renoise.song()end)end;function xAutomation:record(b,c,d,e)TRACE("xAutomation:record(track_idx,param,value,value_mode)",b,c,d,e)assert(type(b)=="number","Expected track_idx to be a number")assert(type(c)=="DeviceParameter","Expected param to be a DeviceParameter")assert(type(d)=="number","Expected value to be a number")if not c.is_automatable then LOG("Could not write automation, parameter is not automatable")return end;if not rns.tracks[b]then LOG("Could not write automation, invalid track index #",b)end;if e then d=xAutomation.get_scaled_value(d,e)end;local f=self:get_position()local g=rns.sequencer.pattern_sequence[f.sequence]if not g then LOG("Could not write automation, invalid sequence index #",f.sequence)end;local h=rns.patterns[g]:track(b)local i=xAutomation.get_or_create_automation(h,c)if not rns.transport.playing or self.follow_mode==xAutomation.FOLLOW_MODE.EDIT_POS then self:clear_range(f.line,1,i)i:add_point_at(f.line,d)else local j=xStreamPos.determine_writeahead()if self.highres_mode then local k=xPlayPos.get()local l=k.line+k.fraction;self:clear_range(l,j,i)i:add_point_at(l,d)else self:clear_range(rns.transport.playback_pos.line,j,i)i:add_point_at(rns.transport.playback_pos.line,d)end end;if self.playmode~=xAutomation.PLAYMODE.AUTOMATIC then i.playmode=self.playmode end end;function xAutomation:has_automation(b,c)if not rns.tracks[b]then LOG("Could not write automation, invalid track index #",b)end;local f=self:get_position()local g=rns.sequencer.pattern_sequence[f.sequence]if not g then LOG("Could not write automation, invalid sequence index #",f.sequence)end;local h=rns.patterns[g]:track(b)local i=h:find_automation(c)return i and true or false end;function xAutomation:clear_range(m,n,i)if rns.transport.playing and self.write_mode==xAutomation.WRITE_MODE.INTERLEAVE then return end;local o=math.min(renoise.Pattern.MAX_NUMBER_OF_LINES,m+n)i:clear_range(m,o)end;function xAutomation:get_position()if self.follow_mode==xAutomation.FOLLOW_MODE.AUTOMATIC then if not rns.transport.playing then return rns.transport.edit_pos else return rns.transport.playback_pos end elseif self.follow_mode==xAutomation.FOLLOW_MODE.EDIT_POS then return rns.transport.edit_pos elseif self.follow_mode==xAutomation.FOLLOW_MODE.PLAY_POS then return rns.transport.playback_pos else error("Unexpected follow mode")end end;function xAutomation.get_or_create_automation(h,c)local i=h:find_automation(c)if not i then i=h:create_automation(c)end;return i end;function xAutomation.get_scaled_value(d,e)TRACE("xAutomation.get_scaled_value(value,value_mode)",d,e)assert(type(d)=="number","Expected value to be a number")assert(type(e)=="string","Expected value_mode to be a string")local p,q;if e:find("7")then p=0;q=127 elseif e:find("14")then p=0;q=16383 else return d end;return cLib.scale_value(d,p,q,0,1)end