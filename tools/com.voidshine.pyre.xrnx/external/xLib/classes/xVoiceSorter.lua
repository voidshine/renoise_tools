cLib.require(_clibroot.."cTable")cLib.require(_xlibroot.."xVoiceRunner")cLib.require(_xlibroot.."xColumns")class'xVoiceSorter'xVoiceSorter.SORT_MODES={"Low → High","High → Low"}xVoiceSorter.SORT_MODE={LOW_TO_HIGH=1,HIGH_TO_LOW=2}xVoiceSorter.SORT_METHODS={"Normal","Unique","Compact"}xVoiceSorter.SORT_METHOD={NORMAL=1,UNIQUE=2,COMPACT=3}xVoiceSorter.MAX_NOTE_COLUMNS=12;xVoiceSorter.ERROR_CODE={TOO_MANY_COLS=1,CANT_PRESERVE_EXISTING=2}function xVoiceSorter:__init(...)TRACE("xVoiceSorter:__init(...)")local a=cLib.unpack_args(...)self.runner=a.runner;self.sort_mode=a.sort_mode or xVoiceSorter.SORT_MODE.LOW_TO_HIGH;self.sort_method=a.sort_method or xVoiceSorter.SORT_METHOD.NORMAL;self.merge_unique=a.merge_unique or true;self.unique_instrument=a.unique_instrument or true;self.selection=nil;self.high_low_columns={}self.sorted={}self.unique_map=nil;self.temp_runs={}self.required_cols=nil end;function xVoiceSorter:reset()self.unique_map={}self.temp_runs={}self.high_low_columns={}end;function xVoiceSorter:sort(b,c,d,e)TRACE("xVoiceSorter:sort(ptrack_or_phrase,selection,trk_idx,seq_idx)",b,c,d,e)assert(type(b)=="PatternTrack"or type(b)=="InstrumentPhrase")assert(type(c)=="table")local f=nil;local g=type(b)=="PatternTrack"if g then assert(type(d)=="number")assert(type(e)=="number")f=rns.tracks[d]end;self.selection=c;local h=xVoiceRunner.COLLECT_MODE.SELECTION;self.runner:collect(b,h,self.selection,d,e)local i=self.runner.voice_runs;if table.is_empty(i)then return true end;if#table.keys(i)==1 and(self.sort_method==xVoiceSorter.SORT_METHOD.NORMAL or self.sort_method==xVoiceSorter.SORT_METHOD.COMPACT)then LOG("Skip sorting single column with normal/compact method")return true end;if self.sort_method==xVoiceSorter.SORT_METHOD.UNIQUE then for j,k in pairs(self.runner.unique_notes)do for l,m in pairs(k)do table.insert(self.unique_map,{note_value=j,instrument_value=self.unique_instrument and l or nil})end end;if#self.runner.unique_notes>xVoiceSorter.MAX_NOTE_COLUMNS then self.required_cols=table.rcopy(self.unique_map)return false,xVoiceSorter.ERROR_CODE.TOO_MANY_COLS end;table.sort(self.unique_map,function(n,o)if self.sort_mode==xVoiceSorter.SORT_MODE.LOW_TO_HIGH then if n.note_value==o.note_value and n.instrument_value and o.instrument_value then return n.instrument_value<o.instrument_value else return n.note_value<o.note_value end elseif self.sort_mode==xVoiceSorter.SORT_MODE.HIGH_TO_LOW then if n.note_value==o.note_value and n.instrument_value and o.instrument_value then return n.instrument_value>o.instrument_value else return n.note_value>o.note_value end end end)end;for p=self.selection.start_line,self.selection.end_line do local q,r=nil,nil;local s=xVoiceRunner.get_runs_on_line(i,p)if self.sort_method==xVoiceSorter.SORT_METHOD.NORMAL then q,r=self:sort_by_note(s,p)elseif self.sort_method==xVoiceSorter.SORT_METHOD.COMPACT then q,r=self:sort_compact(s,p)elseif self.sort_method==xVoiceSorter.SORT_METHOD.UNIQUE then q,r=self:sort_unique(s,p)if#self.unique_map>xVoiceSorter.MAX_NOTE_COLUMNS then self.required_cols=table.rcopy(self.unique_map)return false,xVoiceSorter.ERROR_CODE.TOO_MANY_COLS end end;if r then return false,r end end;local t,u=cTable.bounds(i)local v=#table.keys(self.temp_runs)local w={}local x=0;local y=0;local z=nil;local A;if g then A=f.visible_note_columns else A=b.visible_note_columns end;for j=1,A do if j<c.start_column or j>c.end_column then w[j]=true;if not z and x>0 then z=j end else w[j]=false;x=x+1 end end;if z then local B=1+self.selection.end_column-self.selection.start_column;y=math.abs(v-B)if y>0 then xColumns.shift_note_columns(b,z,y,self.selection.start_line,self.selection.end_line)end end;self.selection.end_column=math.max(A,self.selection.start_column+#self.temp_runs-1)if self.selection.end_column>12 then return false,xVoiceSorter.ERROR_CODE.CANT_PRESERVE_EXISTING end;local C=self.selection.start_column;if C>1 then repeat table.insert(self.temp_runs,1,{})C=C-1 until C==1 end;self.runner.voice_runs=self.temp_runs;if z then local D=A+y;if g then f.visible_note_columns=math.min(12,math.max(D,f.visible_note_columns))else b.visible_note_columns=math.min(12,math.max(D,b.visible_note_columns))end end;self.runner:write(b,self.selection,d)self.runner:purge_voices()return true end;function xVoiceSorter:sort_line_runs(E,p)TRACE("xVoiceSorter:sort_line_runs(t,line_idx)",E,p)table.sort(E,function(n,o)local F=function()return self.unique_instrument and n.voice_run[p].note_value==o.voice_run[p].note_value and n.voice_run[p].instrument_value<255 and o.voice_run[p].instrument_value<255 end;if self.sort_mode==xVoiceSorter.SORT_MODE.LOW_TO_HIGH then if F()then return n.voice_run[p].instrument_value<o.voice_run[p].instrument_value else return n.voice_run[p].note_value<o.voice_run[p].note_value end elseif self.sort_mode==xVoiceSorter.SORT_MODE.HIGH_TO_LOW then if F()then return n.voice_run[p].instrument_value>o.voice_run[p].instrument_value else return n.voice_run[p].note_value>o.voice_run[p].note_value end end end)end;function xVoiceSorter:sort_by_note(s,p)TRACE("xVoiceSorter:sort_by_note(line_runs,line_idx)",s,p)self.sorted=table.rcopy(s)self:sort_line_runs(self.sorted,p)local t,u=self.selection.start_column,self.selection.end_column;for j,G in ipairs(self.sorted)do local H=G.voice_run.number_of_lines;local I=xVoiceRunner.get_initial_notecol(G.voice_run)local J,K,L=self:find_note_column(I.note_value,p,H)if J then cTable.expand(self.temp_runs,K)table.insert(self.temp_runs[K],G.voice_run)self:set_high_low_column(K,I.note_value,I.note_value)else local M=not K;local N=false;if M then K=1 else local k=self.high_low_columns[K]if k then N=I.note_value==k.low_note and I.note_value==k.high_note end end;self:insert_temp_column(K)if not M and not N then local O=L and K-1 or K;local P=L and K or K+1;local Q=self:shift_runs(I.note_value,O,P,p-1)if Q then J,K=self:find_note_column(I.note_value,p,H)end end;self:insert_note_run(K,G.voice_run,p)end end end;function xVoiceSorter:find_note_column(R,p,H)TRACE("xVoiceSorter:find_note_column(note_value,line_idx,num_lines)",R,p,H)local S=nil;local T={}if table.is_empty(self.high_low_columns)then return false end;local t,u=cTable.bounds(self.temp_runs)local U=function(K)local V=nil;local W=nil;local X,Y;T[K]=true;for j=t,u do if T[j]then local k=self.high_low_columns[j]if self.sort_mode==xVoiceSorter.SORT_MODE.HIGH_TO_LOW then if Y and Y>k.low_note and R<=k.low_note then V=j-1 end;if Y and Y>k.high_note and R<=k.high_note then V=j-1 end;if X and X<R then W=j end elseif self.sort_mode==xVoiceSorter.SORT_MODE.LOW_TO_HIGH then if X and X<k.low_note and R>=k.low_note then V=j-1 end;if X and X<k.high_note and R>=k.low_note then V=j-1 end;if Y and Y>R then W=j end;if X and X>R then W=j end end;X=k.high_note;Y=k.low_note end end;if W then for j=W,u do if T[j]then T[j]=false end end end;if V then for j=1,V do if T[j]then T[j]=false end end end end;for K,k in pairs(self.high_low_columns)do if R==k.low_note and R==k.high_note then S=xVoiceRunner.has_room(self.temp_runs,p,K,H)if S then return true,K else U(K)end else U(K)end end;for K=t,u do if T[K]then S=xVoiceRunner.has_room(self.temp_runs,p,K,H)if S then return true,K end end end;local Z=function(K)local k=self.high_low_columns[K]if k.high_note then local _=k.low_note<=R and k.high_note>=R;if self.sort_mode==xVoiceSorter.SORT_MODE.HIGH_TO_LOW then if _ then return false,K+1,true elseif k.low_note>=R then return false,K+1,true else return false,K end elseif self.sort_mode==xVoiceSorter.SORT_MODE.LOW_TO_HIGH then if _ then return false,K+1,true elseif k.high_note<=R then return false,K+1,true elseif k.high_note>=R then return false,K end end end end;for K=t,u do if T[K]then local S,a0,L=Z(K)if type(S)=="boolean"then return S,a0,L end end end;for K=t,u do local S,a0,L=Z(K)if type(S)=="boolean"then return S,a0,L end end;error("shouldn't get here - at least one marked column")end;function xVoiceSorter:shift_runs(R,O,P,p)TRACE("xVoiceSorter:shift_runs(note_value,source_col_idx,target_col_idx,line_idx)",R,O,P,p)assert(type(R)=="number")assert(type(O)=="number")assert(type(P)=="number")assert(type(p)=="number")if p<1 then return false end;local a1=self.temp_runs[O]if not a1 then return false end;local a2,a3=xVoiceRunner.get_high_low_note_values(a1,1,p)if not a2 then return false end;if R==a2 and R==a3 then return false end;if R>a2 or R<a3 then return false end;local a4=xVoiceRunner.get_higher_notes_in_column(self.temp_runs[O],R-1)local a5=1;if not table.is_empty(a4)then for j=1,#a4 do local a6=a1[a4[j].run_idx]a5=j;table.insert(self.temp_runs[P],j,a6)self:clear_temp_run(O,a4[j].run_idx,a4[j].line_idx)end;self:set_high_low_column(P,nil,nil,nil,p)self:set_high_low_column(O,nil,nil,nil,p)return true end;return false end;function xVoiceSorter:clear_temp_run(K,a7)TRACE("xVoiceSorter:clear_temp_run(col_idx,run_idx)",K,a7)local a8=self.temp_runs[K]if not a8[a7]then return end;a8[a7]=nil;if table.is_empty(a8)then self:remove_temp_column(K)end end;function xVoiceSorter:remove_temp_column(K)TRACE("xVoiceSorter:remove_temp_column(col_idx)",K)table.remove(self.temp_runs,K)table.remove(self.high_low_columns,K)end;function xVoiceSorter:insert_temp_column(K,a9)TRACE("xVoiceSorter:insert_temp_column(col_idx,voice_run)",K,a9)assert(type(K)=="number")table.insert(self.temp_runs,K,{a9})table.insert(self.high_low_columns,K,{})local a2,a3=xVoiceRunner.get_high_low_note_values(self.temp_runs[K])self:set_high_low_column(K,a2,a3)end;function xVoiceSorter:set_high_low_column(K,a2,a3,aa,p)TRACE("xVoiceSorter:set_high_low_column(col_idx,high_note,low_note,force,line_idx)",K,a2,a3,aa,p)assert(type(K)=="number")if p then local a8=self.temp_runs[K]local ab,ac=xVoiceRunner.get_column_start_end_line(a8)if ab and ab<p then local a2,a3=xVoiceRunner.get_high_low_note_values(a8,ab,p)self:set_high_low_column(K,a2,a3,true)else self:set_high_low_column(K,nil,nil,true)end;return end;local E=self.high_low_columns[K]if E then if aa then E.high_note=a2;E.low_note=a3 else if E.high_note then E.high_note=a2 and math.max(a2,E.high_note)or nil else E.high_note=a2 end;if E.low_note then E.low_note=a3 and math.min(a3,E.low_note)or nil else E.low_note=a3 end end else self.high_low_columns[K]={low_note=a3,high_note=a2}end end;function xVoiceSorter:insert_note_run(K,a9,p)TRACE("xVoiceSorter:insert_note_run(col_idx,voice_run)",K,a9)cTable.expand(self.temp_runs,K)table.insert(self.temp_runs[K],a9)self:set_high_low_column(K,nil,nil,nil,p+1)end;function xVoiceSorter:sort_unique(s,p)TRACE("xVoiceSorter:sort_unique(line_runs,line_idx)",#s,p)self.sorted=table.rcopy(s)self:sort_line_runs(self.sorted,p)for j,G in ipairs(self.sorted)do local I=xVoiceRunner.get_initial_notecol(G.voice_run)local H=G.voice_run.number_of_lines;local J,K=self:find_unique_column(I,p,H)if not J then K=K+1;self:insert_temp_column(K,G.voice_run)table.insert(self.unique_map,K,{note_value=I.note_value,instrument_value=I.instrument_value})else cTable.expand(self.temp_runs,K)table.insert(self.temp_runs[K],G.voice_run)self.unique_map[K].instrument_value=I.instrument_value end end end;function xVoiceSorter:find_unique_column(I,p,H)TRACE("xVoiceSorter:find_unique_column(notecol,line_idx,num_lines)",I,p,H)local K=nil;local J=false;local S=nil;for j,k in pairs(self.unique_map)do if self:matches_unique_column(I,j)then K=j;break end end;if not K then for j,k in pairs(self.unique_map)do if k.note_value==I.note_value then return false,j end end end;repeat S=xVoiceRunner.has_room(self.temp_runs,p,K,H)if S then J=true;break else K=K+1 end until not self:matches_unique_column(I,K)if not J then K=K-1 end;return J,K end;function xVoiceSorter:matches_unique_column(I,K)TRACE("xVoiceSorter:matches_unique_column(notecol,col_idx)",I,K)local ad=self.unique_map[K]if not ad then return false end;local F=function()return self.unique_instrument and ad.instrument_value and I.instrument_value and I.note_value==ad.note_value end;local ae=F()if ae then return I.instrument_value==ad.instrument_value else return I.note_value==ad.note_value end;return false end;function xVoiceSorter:sort_compact(s,p)TRACE("xVoiceSorter:sort_compact(line_runs,line_idx)",#s,p)self.sorted=table.rcopy(s)self:sort_line_runs(self.sorted,p)for j,G in ipairs(self.sorted)do local H=G.voice_run.number_of_lines;local K=self:find_compact_column(p,H)local af=self.temp_runs[K]if not af then self:insert_temp_column(K,G.voice_run)else cTable.expand(self.temp_runs,K)table.insert(self.temp_runs[K],G.voice_run)end end end;function xVoiceSorter:find_compact_column(p,H)local K=1;local J=false;repeat if xVoiceRunner.has_room(self.temp_runs,p,K,H)then J=true;break else K=K+1 end until not self.temp_runs[K]return K end;function xVoiceSorter:__tostring()return type(self)..", sort_mode="..tostring(self.sort_mode)end