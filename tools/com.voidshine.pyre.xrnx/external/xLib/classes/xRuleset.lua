cLib.require(_clibroot.."cFilesystem")cLib.require(_xlibroot.."xRule")class'xRuleset'xRuleset.DEFAULT_NAME="Untitled ruleset"xRuleset.CURRENT_RULESET="Current Ruleset"function xRuleset:__init(a,b)if not b then b={{}}end;self.xrules=a;self.name=property(self.get_name,self.set_name)self.name_observable=renoise.Document.ObservableString("")self.description=property(self.get_description,self.set_description)self.description_observable=renoise.Document.ObservableString("")self.osc_enabled=property(self.get_osc_enabled,self.set_osc_enabled)self.osc_enabled_observable=renoise.Document.ObservableBoolean(false)self.manage_voices=property(self.get_manage_voices,self.set_manage_voices)self.manage_voices_observable=renoise.Document.ObservableBoolean(false)self.rules={}self.rules_observable=renoise.Document.ObservableNumberList()self.suppress_notifier=false;self.modified=property(self.get_modified,self.set_modified)self.modified_observable=renoise.Document.ObservableBoolean(false)self.active=property(self.get_active,self.set_active)self.active_observable=renoise.Document.ObservableBoolean(true)self.selected_rule_index=property(self.get_selected_rule_index,self.set_selected_rule_index)self.selected_rule_index_observable=renoise.Document.ObservableNumber(1)self.file_path=property(self.get_file_path,self.set_file_path)self.file_path_observable=renoise.Document.ObservableString("")self:parse_definition(b)end;function xRuleset:get_name()return self.name_observable.value end;function xRuleset:set_name(c)local d=c~=self.name_observable.value;self.name_observable.value=c;if d then self.modified=true end end;function xRuleset:get_description()return self.description_observable.value end;function xRuleset:set_description(c)local d=c~=self.description_observable.value;self.description_observable.value=c;if d then self.modified=true end end;function xRuleset:get_osc_enabled()return self.osc_enabled_observable.value end;function xRuleset:set_osc_enabled(c)local d=c~=self.osc_enabled_observable.value;self.osc_enabled_observable.value=c;if d then self.modified=true end end;function xRuleset:get_manage_voices()return self.manage_voices_observable.value end;function xRuleset:set_manage_voices(c)TRACE("xRuleset:set_manage_voices(val)",c)local d=c~=self.manage_voices_observable.value;self.manage_voices_observable.value=c;if d then self.modified=true end end;function xRuleset:get_modified()return self.modified_observable.value end;function xRuleset:set_modified(c)self.modified_observable.value=c end;function xRuleset:get_active()return self.active_observable.value end;function xRuleset:set_active(c)self.active_observable.value=c end;function xRuleset:get_selected_rule_index()return self.selected_rule_index_observable.value end;function xRuleset:set_selected_rule_index(c)self.selected_rule_index_observable.value=c end;function xRuleset:get_file_path()return self.file_path_observable.value end;function xRuleset:set_file_path(c)self.file_path_observable.value=c end;function xRuleset:add_rule(e,f)if not f then f=#self.rules+1 end;local g=xRule(e)table.insert(self.rules,f,g)self.rules_observable:insert(f,1)self:attach_to_rule(f)self.modified=true end;function xRuleset:rename(h)if not cFilesystem.validate_filename(h)then return false,"The name contains illegal characters"end;local i=cFilesystem.get_path_parts(self.file_path)local j=cFilesystem.unixslashes(("%s/%s.lua"):format(i,h))if io.exists(j)then return false,"A file already exist with that name"end;local k,l=cFilesystem.rename(self.file_path,j)if not k then return false,l end;self.name=h;self.file_path=j;return true end;function xRuleset:remove_rule(f)local m=self.rules[f]if not m then local l=("Could not remove rule with index #%d- it doesn't exist"):format(f)return false,l end;table.remove(self.rules,f)self.rules_observable:remove(f)self.modified=true;return true end;function xRuleset:get_rule_name(n)assert(type(n)=="number","Expected number as argument")local g=self.rules[n]if g.name==""then return string.format("Rule #%.2d",n)else return g.name end end;function xRuleset:get_rule_by_name(o)for p,q in ipairs(self.rules)do local r=self:get_rule_name(p)if r==o then return q,p end end end;function xRuleset:match_message(s,t,n,u)assert(type(t)=="number","Expected ruleset_idx to be a number")local function v(m,n)if not u and(not m.midi_enabled and type(s)=="xMidiMessage")then return end;local w,x=m:match(s,self.xrules,t)if x then for y,q in ipairs(w)do self.xrules:transmit(q,s,t,n)end end end;if n then v(self.rules[n],n)else for f,m in ipairs(self.rules)do v(m,f)end end end;function xRuleset:compile()for p,m in ipairs(self.rules)do local k,l=m:compile()if l then LOG(l)end end end;function xRuleset:parse_definition(b)self.rules={}for p=#self.rules_observable,1,-1 do self.rules_observable:remove(p)end;self.suppress_notifier=true;self.osc_enabled_observable.value=b.osc_enabled or false;self.manage_voices_observable.value=b.manage_voices or false;self.active_observable.value=b.active or true;self.description_observable.value=b.description or""for p,q in ipairs(b)do self:add_rule(q)end;self.suppress_notifier=false;return true end;function xRuleset:load_definition(z)assert(type(z)=="string","Expected a string as argument")assert(z~="","Expected a non-empty string as argument")local A,l=cFilesystem.load_string(z)if not A then return false,l end;local k=xRuleset.looks_like_definition(A)if not k then return false,("The file %s does not look like a ruleset definition"):format(z)end;local k,l=pcall(function()assert(loadfile(z))end)if not k then l="ERROR: Failed to load the definition '"..z.."' - "..l;return false,l end;local B=assert(loadfile(z))()local k,l=self:parse_definition(B)if not k then l="ERROR: Failed to load the definition '"..z.."' - "..l;return false,l end;self.name=cFilesystem.get_raw_filename(z)self.file_path=z;return true end;function xRuleset:serialize()local C=""C="-----------------------------------------------------------".."\n-- Ruleset definition for xRules".."\n-- More info @ http://www.renoise.com/tools/xrules".."\n-----------------------------------------------------------".."\nreturn {".."\nosc_enabled = "..tostring(self.osc_enabled)..",".."\nmanage_voices = "..tostring(self.manage_voices)..",".."\ndescription = \""..cLib.serialize_object(self.description).."\",".."\n"for p,q in ipairs(self.rules)do C=C..q:serialize()if self.rules[p+1]then C=C..",\n"end end;C=C.."\n}"return C end;function xRuleset:save_definition(z)if not z then z=self.file_path end;local A=self:serialize()local k,l=cFilesystem.write_string_to_file(z,A)if not k then return false,l end;return true end;function xRuleset:attach_to_rule(n)local g=self.rules[n]g.modified_observable:add_notifier(function()self.modified=true end)end;function xRuleset:__tostring()return type(self)..", name:"..tostring(self.name)..", osc_enabled:"..tostring(self.osc_enabled)..", manage_voices:"..tostring(self.manage_voices)..", modified:"..tostring(self.modified)..", active:"..tostring(self.active)..", file_path:"..tostring(self.file_path)..", description:"..tostring(self.description)end;function xRuleset.looks_like_definition(A)if not string.find(A,"return[%s]*{")or not string.find(A,"\[?\"?actions\]?\"?[%s]*=[%s]*{")or not string.find(A,"\[?\"?conditions\]?\"?[%s]*=[%s]*{")then return false else return true end end;function xRuleset.get_suggested_name(o)if not o then o=xRuleset.DEFAULT_NAME end;local z=xRuleset.get_normalized_file_path(o)local D=cFilesystem.ensure_unique_filename(z)local E=cFilesystem.get_raw_filename(D)return E end;function xRuleset.get_normalized_file_path(o)return("%s%s.lua"):format(xRules.RULESET_FOLDER,o)end