cLib.require(_xlibroot.."xNoteColumn")cLib.require(_xlibroot.."xEffectColumn")class'xLinePattern'xLinePattern.MAX_NOTE_COLUMNS=12;xLinePattern.MAX_EFFECT_COLUMNS=8;xLinePattern.EMPTY_VALUE=255;xLinePattern.EMPTY_STRING="00"xLinePattern.EFFECT_CHARS={"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"}function xLinePattern:__init(a,b)self.note_columns=table.create()self.effect_columns=table.create()self:apply_descriptor(a,b)end;function xLinePattern:apply_descriptor(a,b)if not table.is_empty(a)then local c,d=cTable.bounds(a)for e=1,math.min(xLinePattern.MAX_NOTE_COLUMNS,d)do self.note_columns[e]=xNoteColumn(a[e])end end;if not table.is_empty(b)then local c,d=cTable.bounds(b)for e=1,math.min(xLinePattern.MAX_EFFECT_COLUMNS,d)do self.effect_columns[e]=xEffectColumn(b[e])end end end;function xLinePattern.set_subcolumn_visibility(f,g,h)TRACE("xLinePattern.set_subcolumn_visibility(rns_track_or_phrase,token,val)",f,g,h)local i={["volume_value"]=function()f.volume_column_visible=h end,["panning_value"]=function()f.panning_column_visible=h end,["delay_value"]=function()f.delay_column_visible=h end,["effect_number_value"]=function()f.sample_effects_column_visible=h end,["effect_amount_value"]=function()f.sample_effects_column_visible=h end}if i[g]then i[g]()return end;error("Unexpected token - use `xNoteColumn.subcolumn_tokens`")end;function xLinePattern:do_write(j,k,l,m,n,o,p)local q,r,s,t,u;local f;if l then q,r,s,t,u=xLine.resolve_pattern_line(j,k,l)f=t else q=xLine.resolve_phrase_line(k)f=m end;local v=t.type==renoise.Track.TRACK_TYPE_SEQUENCER;if v then self:process_columns(q.note_columns,f,self.note_columns,n,o,p)else if self.note_columns then LOG("Can only write note-columns to a sequencer track")end end;self:process_columns(q.effect_columns,f,self.effect_columns,n,o,p)end;function xLinePattern:process_columns(w,f,x,n,o,p)local y=1;local z=type(w[1])=="NoteColumn"local A=function(B,g)if not xNoteColumn.subcolumn_is_empty(B,g)then xLinePattern.set_subcolumn_visibility(f,g,true)end end;for e,C in ipairs(w)do if not o and not n and e>y then break elseif e>#w then break end;local D=x[e]if D then if o then y=e end;local E={}local F=nil;if type(D)=="table"then if z then D=xNoteColumn(D)else D=xEffectColumn(D)end end;if type(D)=="xNoteColumn"then E=xNoteColumn.output_tokens;F=o and A elseif type(D)=="xEffectColumn"then E=xEffectColumn.output_tokens else error("Unexpected column type: "..type(D))end;D:do_write(C,E,p,F)else if p then C:clear()end end end;if z then f.visible_note_columns=y else f.visible_effect_columns=y end end;function xLinePattern.do_read(q,G,H)local I=tostring(q)local J,K={},{}local L;for M=1,G do L=M*18-17;local N=string.sub(I,L,L+2)local O=string.sub(I,L+3,L+4)local P=string.sub(I,L+5,L+6)local Q=string.sub(I,L+7,L+8)local R=string.sub(I,L+9,L+10)local S=string.sub(I,L+11,L+12)local T=string.sub(I,L+13,L+14)J[M]={note_string=N,instrument_string=O,volume_string=P,panning_string=Q,delay_string=R,effect_number_string=S,effect_amount_string=T,note_value=xNoteColumn.note_string_to_value(N),instrument_value=xNoteColumn.instr_string_to_value(O),delay_value=xNoteColumn.delay_string_to_value(R),volume_value=xNoteColumn.column_string_to_value(P),panning_value=xNoteColumn.column_string_to_value(Q),effect_number_value=xEffectColumn.number_string_to_value(S),effect_amount_value=xEffectColumn.amount_string_to_value(T)}end;for U=1,H do L=U*7+209;local V=string.sub(I,L+1,L+2)local W=string.sub(I,L+3,L+4)K[U]={number_string=V,amount_string=W,number_value=xEffectColumn.number_string_to_value(V),amount_value=xEffectColumn.amount_string_to_value(W)}end;return J,K end;function xLinePattern.get_effect_command(X,k,Y,Z,_)assert(type(X)=="Track","Expected renoise.Track as argument")assert(type(k)=="PatternLine","Expected renoise.PatternLine as argument")assert(type(Y)=="string","Expected string as argument")assert(type(Z)=="number","Expected number as argument")if#Y==1 then return xLinePattern.get_effect_subcolumn_command(X,k,Y,Z,_)elseif#Y==2 then return xLinePattern.get_effect_column_command(X,k,Y,Z,_)else error("Unexpected effects type")end end;function xLinePattern.get_effect_subcolumn_command(X,k,Y,Z,_)TRACE("xLinePattern.get_effect_subcolumn_command(track,line,fx_type,notecol_idx,visible_only)",X,k,Y,Z,_)error("Not yet implemented")end;function xLinePattern.get_effect_column_command(X,k,Y,Z,_)TRACE("xLinePattern.get_effect_column_command(track,line,fx_type,notecol_idx,visible_only)",X,k,Y,Z,_)local a0=table.create()local a1=1;local a2=not _ and true or X.sample_effects_column_visible;if a2 then for e,a3 in ipairs(k.note_columns)do if _ and e>X.visible_note_columns then break else local a4=not Z and true or e==Z;if a4 then if a3.effect_number_string==Y then a0:insert({column_index=a1,column_type=xEffectColumn.TYPE.EFFECT_NOTECOLUMN,amount_value=a3.effect_amount_value,amount_string=a3.effect_amount_string})end end;a1=a1+1 end end else a1=X.visible_note_columns+1 end;for e,U in ipairs(k.effect_columns)do if _ and e>X.visible_effect_columns then break else if U.number_string==Y then a0:insert({column_index=a1,column_type=xEffectColumn.TYPE.EFFECT_COLUMN,amount_value=U.amount_value,amount_string=U.amount_string})end;a1=a1+1 end end;return a0 end;function xLinePattern.get_available_effect_column(X,k,_,a5)TRACE("xLinePattern.get_available_effect_column(track,line,visible_only,from_column)",X,k,_,a5)local a1=1;local a2=not _ and true or X.sample_effects_column_visible;if a2 then for e,a3 in ipairs(k.note_columns)do if _ and e>X.visible_note_columns then break else if a5 and a1<a5 then elseif a3.effect_number_value==0 and a3.effect_amount_value==0 then return{column_index=a1,column_type=xEffectColumn.TYPE.EFFECT_NOTECOLUMN}end;a1=a1+1 end end else a1=X.visible_note_columns+1 end;for e,U in ipairs(k.effect_columns)do if _ and e>X.visible_effect_columns then break else if a5 and a1<a5 then elseif U.is_empty then return{column_index=a1,column_type=xEffectColumn.TYPE.EFFECT_COLUMN}end;a1=a1+1 end end end;function xLinePattern.set_effect_column_command(X,k,a6,a7,a8,a9)TRACE("xLinePattern.set_effect_column_command(track,line,fx_number,fx_amount,column_index,overwrite)",X,k,a6,a7,a8,a9)local _=true;local Z=-1;local aa=xLinePattern.get_effect_column_command(X,k,a6,Z,_)if not table.is_empty(aa)and aa[1].amount_value==a7 then return nil,"Effect Command already exists"else local a5=a8 and a8 or X.visible_note_columns+1;local aa=xLinePattern.get_available_effect_column(X,k,_,a5)if aa then a8=aa.column_index else if X.visible_effect_columns<X.max_effect_columns then local y=X.visible_effect_columns+1;X.visible_effect_columns=y;a8=X.sample_effects_column_visible and X.visible_note_columns+y or y end end end;if not a8 then return nil,"No effect-column was matched"end;local ab=X.sample_effects_column_visible and X.visible_note_columns or 0;if a8>ab then local ac=k.effect_columns[a8-X.visible_note_columns]ac.number_string=a6;ac.amount_value=math.floor(a7)return ac else local ac=k.note_columns[a8]ac.effect_number_string=a6;ac.effect_amount_value=math.floor(a7)return ac end end;function xLinePattern.get_midi_command(X,k)TRACE("xLinePattern.get_midi_command(track,line)",X,k)assert(type(X)=="Track","Expected renoise.Track as argument")assert(type(k)=="PatternLine","Expected renoise.PatternLine as argument")local B=k.note_columns[X.visible_note_columns]local ad=k.effect_columns[1]if B.is_empty or ad.is_empty then return end;local ae=xEffectColumn.amount_string_to_value(ad.number_string)if not ae then return end;if B.instrument_value<255 and B.panning_string:sub(1,1)=="M"then local af=tonumber(B.panning_string:sub(2,2))return xMidiCommand{instrument_index=B.instrument_value+1,message_type=af,number_value=ad.number_value,amount_value=ad.amount_value}end end;function xLinePattern.set_midi_command(X,k,ag,ah,ai)assert(type(X)=="Track","Expected renoise.Track as argument")assert(type(k)=="PatternLine","Expected renoise.PatternLine as argument")assert(type(ag)=="xMidiCommand","Expected xMidiCommand as argument")ah=ah or true;ai=ai or false;local B=k.note_columns[X.visible_note_columns]local ad=k.effect_columns[1]if not ai and not ad.is_empty then local aj=xLinePattern.get_midi_command(X,k)if not aj then local ae=xEffectColumn.amount_string_to_value(ad.number_string)if not ae then for e=2,xLinePattern.MAX_EFFECT_COLUMNS do local ak=k.effect_columns[e]if ak.is_empty then ak.number_value=ad.number_value;ak.amount_value=ad.amount_value;ad:clear()if ah and e>X.visible_effect_columns then X.visible_effect_columns=e end;break end end end end end;B.instrument_value=ag.instrument_index-1;B.panning_string=("M%d"):format(ag.message_type)ad.number_value=ag.number_value;ad.amount_value=ag.amount_value;if ah then if not X.panning_column_visible then X.panning_column_visible=true end;if X.visible_effect_columns==0 then X.visible_effect_columns=1 end end end;function xLinePattern.clear_midi_command(X,k)TRACE("xLinePattern.clear_midi_command(track,line)",X,k)assert(type(X)=="Track","Expected renoise.Track as argument")assert(type(k)=="PatternLine","Expected renoise.PatternLine as argument")local B=k.note_columns[X.visible_note_columns]local ad=k.effect_columns[1]B.panning_value=xLinePattern.EMPTY_VALUE;ad.number_value=0;ad.amount_value=0;if B.volume_value==xLinePattern.EMPTY_VALUE and B.delay_value==0 and B.note_value==121 then B.instrument_value=xLinePattern.EMPTY_VALUE end end;function xLinePattern:__tostring()return type(self).."#note_columns="..tostring(#self.note_columns).."#effect_columns="..tostring(#self.effect_columns)end