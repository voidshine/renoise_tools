cLib.require(_xlibroot.."xLine")cLib.require(_xlibroot.."xSongPos")cLib.require(_xlibroot.."xStreamPos")cLib.require(_xlibroot.."xAutomation")cLib.require(_xlibroot.."xNoteColumn")cLib.require(_xlibroot.."xLinePattern")cLib.require(_xlibroot.."xPatternSequencer")class'xStreamBuffer'xStreamBuffer.MUTE_MODES={"None","Off"}xStreamBuffer.MUTE_MODE={NONE=1,OFF=2}xStreamBuffer.PLAYMODES={"Points","Linear","Cubic"}xStreamBuffer.PLAYMODE={POINTS=1,LINEAR=2,CUBIC=3}function xStreamBuffer:__init(a)TRACE("xStreamBuffer:__init(xpos)",a)assert(type(a)=="xStreamPos")self.xpos=a;self.callback=nil;self.input_callback=nil;self.callback_status_observable=renoise.Document.ObservableString("")self.read_track_index=property(self.get_read_track_index,self.set_read_track_index)self.read_track_index_observable=renoise.Document.ObservableNumber(1)self.write_track_index=property(self.get_write_track_index,self.set_write_track_index)self.write_track_index_observable=renoise.Document.ObservableNumber(1)self.mute_mode=property(self.get_mute_mode,self.set_mute_mode)self.mute_mode_observable=renoise.Document.ObservableNumber(xStreamBuffer.MUTE_MODE.OFF)self.active=property(self.get_active,self.set_active)self.active_observable=renoise.Document.ObservableBoolean(false)self.expand_columns=property(self.get_expand_columns,self.set_expand_columns)self.expand_columns_observable=renoise.Document.ObservableBoolean(true)self.include_hidden=property(self.get_include_hidden,self.set_include_hidden)self.include_hidden_observable=renoise.Document.ObservableBoolean(false)self.clear_undefined=property(self.get_clear_undefined,self.set_clear_undefined)self.clear_undefined_observable=renoise.Document.ObservableBoolean(true)self.automation_playmode=property(self.get_automation_playmode,self.set_automation_playmode)self.automation_playmode_observable=renoise.Document.ObservableNumber(xStreamBuffer.PLAYMODE.LINEAR)self.input_buffer=nil;self.output_buffer=nil;self.scheduled=nil;self.highest_xinc=nil;self.lowest_xinc=nil;self.mute_xinc=nil;self:clear()end;function xStreamBuffer:get_automation_playmode()return self.automation_playmode_observable.value end;function xStreamBuffer:set_automation_playmode(b)self.automation_playmode_observable.value=b end;function xStreamBuffer:get_write_track_index()return self.write_track_index_observable.value end;function xStreamBuffer:set_write_track_index(b)self.write_track_index_observable.value=b end;function xStreamBuffer:get_read_track_index()return self.read_track_index_observable.value end;function xStreamBuffer:set_read_track_index(b)self.read_track_index_observable.value=b end;function xStreamBuffer:get_include_hidden()return self.include_hidden_observable.value end;function xStreamBuffer:set_include_hidden(b)self.include_hidden_observable.value=b end;function xStreamBuffer:get_clear_undefined()return self.clear_undefined_observable.value end;function xStreamBuffer:set_clear_undefined(b)self.clear_undefined_observable.value=b end;function xStreamBuffer:get_expand_columns()return self.expand_columns_observable.value end;function xStreamBuffer:set_expand_columns(b)self.expand_columns_observable.value=b end;function xStreamBuffer:get_mute_mode()return self.mute_mode_observable.value end;function xStreamBuffer:set_mute_mode(b)self.mute_mode_observable.value=b end;function xStreamBuffer:get_active()return self.active_observable.value end;function xStreamBuffer:set_active(b)TRACE("xStreamBuffer:set_active(val)",b)self.active_observable.value=b end;function xStreamBuffer:refresh_input_buffer()TRACE("xStreamBuffer:refresh_input_buffer()")local c=xSongPos.create(self.xpos.pos)local d=self.xpos.xinc;local e=xStreamPos.determine_writeahead()for f=0,e-1 do self:_obtain_and_store_input(d,c)c=xSongPos.increase_by_lines(1,c)d=d+1 end;self:wipe_futures()end;function xStreamBuffer:_obtain_and_store_input(d,c)TRACE("xStreamBuffer:_obtain_and_store_input(xinc,pos)",d,c)local g=nil;if self.input_callback then TRACE(">>> xStreamBuffer:_obtain_and_store_input - from callback, xinc:",d)g=self.input_callback(d)elseif self.read_track_index>0 then TRACE(">>> xStreamBuffer:_obtain_and_store_input - from pattern, xinc",d,"pos:",c,"read_track_index:",self.read_track_index)g=xLine.do_read(c.sequence,c.line,self.include_hidden,self.read_track_index)end;if not g then TRACE(">>> xStreamBuffer:_obtain_and_store_input - empty_xline as fallback")g=table.rcopy(xLine.EMPTY_XLINE)end;self.input_buffer[d]=g;return g end;function xStreamBuffer:wipe_futures()TRACE("xStreamBuffer:wipe_futures()")local d=self.xpos.xinc;for h=d,self.highest_xinc do self.output_buffer[h]=nil end;self.highest_xinc=d-1;self.scheduled={}TRACE(">>> xStreamBuffer:wipe_futures - highest_xinc",self.highest_xinc)end;function xStreamBuffer:clear()TRACE("xStreamBuffer:clear()")self.highest_xinc=-1;self.lowest_xinc=0;if self.mute_xinc then self.mute_xinc=-1 end;self.input_buffer={}self.output_buffer={}self.scheduled={}end;function xStreamBuffer:_get_songpos(d)TRACE("xStreamBuffer:_get_songpos(xinc)",d)local i=d-self.xpos.xinc;return xSongPos.increase_by_lines(i,self.xpos.pos)end;function xStreamBuffer:schedule_line(g,d)TRACE("xStreamBuffer:schedule_line(xline,xinc)",g,d)self.scheduled[d]=xLine(g)end;function xStreamBuffer:schedule_note_column(j,k,d)TRACE("xStreamBuffer:schedule_note_column(xnotecol,col_idx,xinc)",j,k,d)assert(type(k)=="number")if not d then d=self:_get_immediate_xinc()end;local g=self:_read_input_buffer(d,self:_get_songpos(d))g.note_columns[k]=j;self:schedule_line(g,d)end;function xStreamBuffer:schedule_effect_column(l,k,d)TRACE("xStreamBuffer:schedule_effect_column(xeffectcol,col_idx,xinc)",l,k,d)assert(type(k)=="number")if not d then d=self:_get_immediate_xinc()end;local g=self:_read_input_buffer(d,self:_get_songpos(d))g.effect_columns[k]=l;self:schedule_line(g,d)end;function xStreamBuffer:_get_immediate_xinc()TRACE("xStreamBuffer:_get_immediate_xinc()")return self.xpos.xinc+rns.transport.playing and 1 or 0 end;function xStreamBuffer:mute()TRACE("xStreamBuffer:mute()")local function m()local n={}local o=rns.tracks[self.write_track_index]local p=o.visible_note_columns;for q=1,p do table.insert(n,{note_value=xNoteColumn.NOTE_OFF_VALUE,instrument_value=xLinePattern.EMPTY_VALUE,volume_value=xLinePattern.EMPTY_VALUE,panning_value=xLinePattern.EMPTY_VALUE,delay_value=0})end;return n end;local d=self:_get_immediate_xinc()if self.mute_mode==xStreamBuffer.MUTE_MODE.OFF then local g={}g.note_columns=m()self:schedule_line(g,d)self:schedule_line(g,d+1)self.mute_xinc=d+1 else self.mute_xinc=d end;self:immediate_output()end;function xStreamBuffer:unmute()TRACE("xStreamBuffer:unmute()")self.mute_xinc=nil;self:immediate_output()end;function xStreamBuffer:_create_content(d,c)TRACE("xStreamBuffer:_create_content(xinc,pos)",d,c)local g=self:_read_input_buffer(d,c)local r,s;if d>self.highest_xinc then r,s=pcall(function()g=self.callback(d,g,c)end)if not r and s then LOG("*** Error: please review the callback function - "..s)self.callback_status_observable.value=s end end;if type(g)=="table"then r,s=pcall(function()g=xLine(g)end)if not r and s then LOG("*** Error: "..s)self.callback_status_observable.value=s end;if not r then g=xLine(xLine.EMPTY_XLINE)end end;if g then self.output_buffer[d]=g;self.highest_xinc=math.max(d,self.highest_xinc)TRACE(">>> xStreamBuffer._create_content - self.highest_xinc",self.highest_xinc)end end;function xStreamBuffer:get_output(d)TRACE("xStreamBuffer:get_output(xinc)",d)local g=nil;if not self.active or self.mute_xinc and d>self.mute_xinc then TRACE(">>> xStreamBuffer:get_output - running silent (muted or inactive)")g=table.rcopy(xLine.EMPTY_XLINE)elseif self.scheduled[d]then g=self.scheduled[d]TRACE(">>> xStreamBuffer:get_output - scheduled content",g)else g=self.output_buffer[d]TRACE(">>> xStreamBuffer:get_output - regular content",g)end;if type(g)=="table"then g=xLine(g)end;return g end;function xStreamBuffer:_read_input_buffer(d,c)TRACE("xStreamBuffer:_read_input_buffer(xinc,pos)",d,c)assert(type(d)=="number")assert(type(c)~="nil")local g=nil;if self.scheduled[d]then g=self.scheduled[d]elseif self.input_buffer[d]then g=self.input_buffer[d]else g=self:_obtain_and_store_input(d,c)end;return xLine(g)end;function xStreamBuffer:immediate_output(t)TRACE("xStreamBuffer:immediate_output(get_input)",t)self:wipe_futures()local d=self:_get_immediate_xinc()local c=xSongPos.increase_by_lines(1,self.xpos.pos)if t then self.input_buffer={}self:_obtain_and_store_input(d,c)end;self:write_output(c,d,1)end;function xStreamBuffer:write_output(c,d,u)TRACE("xStreamBuffer:write_output(pos,xinc,num_lines)",c,d,u)local v=os.clock()if not self.active then LOG("*** xStreamBuffer:write_output - not active")return end;if not self.callback then LOG("*** xStreamBuffer:write_output - no callback defined")return end;if not u then u=rns.transport.playing and xStreamPos.determine_writeahead()or 1 end;local w=self.xpos.xinc-1;for h=w,self.lowest_xinc,-1 do self.output_buffer[h]=nil;self.input_buffer[h]=nil;self.scheduled[h]=nil end;self.lowest_xinc=w;local x=self.highest_xinc;local y=xSongPos.create(c)for h=0,u do if not self.output_buffer[h+d]and not self.scheduled[h+d]then self:_create_content(h+d,y)end;y=xSongPos.increase_by_lines(1,y)end;local y=rns.transport.playback_pos;y.line=c.line;local z=xPatternSequencer.get_number_of_lines(c.sequence)local A=math.min(u-1,u-(self.highest_xinc-x))A=math.max(0,A)for h=A,u-1 do y.sequence=c.sequence;y.line=c.line+h;if y.line>z then y=xSongPos.normalize(y)self:write_output(y,d+h,u-h)return end;local B=y.line;if rns.transport.loop_block_enabled then y.line=xSongPos.enforce_block_boundary(c,h)if B~=y.line then self:write_output(y,d+h,u-h)return end end;if self.write_track_index==0 then LOG("*** skip output - no write_track_index has been defined")else local C=nil;local g=self:get_output(d+h)self:write_line(g,y,C,z)end end end;function xStreamBuffer:write_line(g,c,C,z)TRACE("xStreamBuffer:write_line(xline,pos,phrase,patt_num_lines)",g,c,C,z)if not self.active then return end;if type(g)~="xLine"then LOG("*** Expected an instance of xline for output - sequence:",c.sequence,"line:",c.line)return end;local D=nil;local E=nil;local F=rns.selected_automation_parameter;if F and g.automation then if c.sequence~=E then E=c.sequence;D=self:resolve_automation(c.sequence)end;if D then if F.value_quantum==0 then D.playmode=self.automation_playmode end end end;local r,s=pcall(function()g:do_write(c.sequence,c.line,self.write_track_index,C,D,z,self.include_hidden,self.expand_columns,self.clear_undefined)end)if not r then LOG("*** WARNING: an error occurred while writing pattern-line - "..s)end end;function xStreamBuffer:resolve_automation(G)TRACE("xStreamBuffer:resolve_automation(seq_idx)",G)local H,I=xPatternSequencer.get_pattern_at_index(G)if not H then LOG("*** xStreamBuffer:resolve_automation - Could not find pattern")return end;local F=rns.selected_automation_parameter;if not F or not F.is_automatable then LOG("*** xStreamBuffer:resolve_automation - Could not device_param or not automatable")return end;local J=H.tracks[self.read_track_index]if not F or not F.is_automatable then LOG("*** xStreamBuffer:resolve_automation - Could not find pattern-track")return end;return xAutomation.get_or_create_automation(J,F)end