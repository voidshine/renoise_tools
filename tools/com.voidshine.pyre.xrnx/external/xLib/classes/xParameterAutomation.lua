cLib.require(_xlibroot.."xEnvelope")cLib.require(_xlibroot.."xPatternSequencer")class'xParameterAutomation'xParameterAutomation.APPLY_MODE={REPLACE=1,MIX_PASTE=2}xParameterAutomation.LINE_BOUNDARY=0.99609375;xParameterAutomation.LINE_BOUNDARY_INV=1-xParameterAutomation.LINE_BOUNDARY;function xParameterAutomation.cut(a,b,c,d,e)TRACE("xParameterAutomation.cut(param,seq_range,track_idx,device_idx,yield_at)",a,b,c,d,e)local f=xParameterAutomation.copy(a,b,c,d,e)if not f then return nil else return xParameterAutomation.clear(a,b,c)and f or nil end end;function xParameterAutomation.copy(a,b,c,d,e)TRACE("xParameterAutomation.copy(param,seq_range,track_idx,device_idx,yield_at)",a,b,c,d,e)assert(type(a)=="DeviceParameter")assert(type(b)=="table")assert(type(c)=="number")assert(type(d)=="number")if not a.is_automatable then return nil end;local g=xEnvelope()local h=rns.tracks[c]local i=h.devices[d]local j=0;for k=b.start_sequence,b.end_sequence do local l=k==b.start_sequence;local m=k==b.end_sequence;local n,o=xPatternSequencer.get_pattern_at_index(k)local p=n.tracks[c]local q=p:find_automation(a)if q then for r,s in ipairs(q.points)do local t=s.time-j;if m and b.end_line<math.floor(t)then break elseif l and b.start_line>math.floor(t)then else table.insert(g.points,{playmode=q.playmode,time=s.time+j-(b.start_line-1),value=s.value})end end end;j=j+n.number_of_lines;if e==xLib.YIELD_AT.PATTERN then coroutine.yield()end end;return g end;function xParameterAutomation.clear(a,b,c)TRACE("xParameterAutomation.clear(param,seq_range,track_idx)",a,b,c)assert(type(c)=="number")assert(type(a)=="DeviceParameter")assert(type(b)=="table")if not a.is_automatable then return nil end;for k=b.start_sequence,b.end_sequence do local n,o=xPatternSequencer.get_pattern_at_index(k)local p=n.tracks[c]local q=p:find_automation(a)if q then xParameterAutomation._clear_impl(q,b,k,n.number_of_lines)end end;return true end;function xParameterAutomation.paste(u,v,a,b,c,e)TRACE("xParameterAutomation.paste(envelope,apply_mode,param,seq_range,track_idx,yield_at)",u,v,a,b,c,e)assert(type(u)=="xEnvelope")assert(type(v)=="number")assert(type(a)=="DeviceParameter")assert(type(b)=="table")assert(type(c)=="number")local j=0;local w=1;for k=b.start_sequence,b.end_sequence do local l=k==b.start_sequence;local m=k==b.end_sequence;local n,o=xPatternSequencer.get_pattern_at_index(k)local p=n.tracks[c]local q=p:find_automation(a)if q then if v==xParameterAutomation.APPLY_MODE.REPLACE then xParameterAutomation._clear_impl(q,b,k,n.number_of_lines)end end;for x=w,#u.points do local s=u.points[x]local t=s.time-j+b.start_line;local y=function()if not q then q=p:create_automation(a)end;q:add_point_at(t-1,s.value)q.playmode=s.playmode end;if m and b.end_line+1<math.floor(t)then y()break elseif l and b.start_line>math.floor(t)then elseif n.number_of_lines+1<math.floor(t)then w=x;break else y()end;if x==#u.points then w=x;break end end;j=j+n.number_of_lines;if e==xLib.YIELD_AT.PATTERN then coroutine.yield()end end;return true end;function xParameterAutomation._clear_impl(q,b,k,z)local A,B=xSequencerSelection.pluck_from_range(b,k,z)if A==1 and B==z then q:clear()else local C=B+xParameterAutomation.LINE_BOUNDARY;q:clear_range(A,C)if q:has_point_at(C)then q:remove_point_at(C)end end end