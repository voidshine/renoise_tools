cLib.require(_xlibroot.."xMidiMessage")class'xVoiceManager'xVoiceManager.EVENTS={"released","triggered","stolen"}xVoiceManager.EVENT={RELEASED="released",TRIGGERED="triggered",STOLEN="stolen"}function xVoiceManager:__init(...)TRACE("xVoiceManager:__init(...)",...)local a=cLib.unpack_args(...)self.voice_limit=property(self.get_voice_limit,self.set_voice_limit)self.voice_limit_observable=renoise.Document.ObservableNumber(a.voice_limit or 0)self.duration=property(self.get_duration,self.set_duration)self.duration_observable=renoise.Document.ObservableNumber(a.duration or 0)self.column_allocation=property(self.get_column_allocation,self.set_column_allocation)self.column_allocation_observable=renoise.Document.ObservableBoolean(a.column_allocation or false)self.follow_track=property(self.get_follow_track,self.set_follow_track)self.follow_track_observable=renoise.Document.ObservableBoolean(a.follow_track or true)self.follow_instrument=property(self.get_follow_instrument,self.set_follow_instrument)self.follow_instrument_observable=renoise.Document.ObservableBoolean(a.follow_instrument or true)self.follow_octave=property(self.get_follow_octave,self.set_follow_octave)self.follow_octave_observable=renoise.Document.ObservableBoolean(a.follow_octave or true)self.released_index=0;self.released_observable=renoise.Document.ObservableBang()self.triggered_index=0;self.triggered_observable=renoise.Document.ObservableBang()self.stolen_index=0;self.stolen_observable=renoise.Document.ObservableBang()self.voices={}self.voices_observable=renoise.Document.ObservableNumberList()renoise.tool().app_new_document_observable:add_notifier(function()rns=renoise.song()self:_attach_to_song()end)self:_attach_to_song()end;function xVoiceManager:get_voice_limit()return self.voice_limit_observable.value end;function xVoiceManager:set_voice_limit(b)if b<#self.voices then for c=1,#self.voices-b do self:release(c)end end;self.voice_limit_observable.value=b end;function xVoiceManager:get_duration()return self.duration_observable.value end;function xVoiceManager:set_duration(b)self.duration_observable.value=b end;function xVoiceManager:get_column_allocation()return self.column_allocation_observable.value end;function xVoiceManager:set_column_allocation(b)self.column_allocation_observable.value=b end;function xVoiceManager:get_follow_track()return self.follow_track_observable.value end;function xVoiceManager:set_follow_track(b)self.follow_track_observable.value=b end;function xVoiceManager:get_follow_instrument()return self.follow_instrument_observable.value end;function xVoiceManager:set_follow_instrument(b)self.follow_instrument_observable.value=b end;function xVoiceManager:get_follow_octave()return self.follow_octave_observable.value end;function xVoiceManager:set_follow_octave(b)self.follow_octave_observable.value=b end;function xVoiceManager:input_message(d)TRACE("xVoiceManager:input_message(xmsg)",d)assert(type(d)=="xMidiMessage","Expected xmsg to be xMidiMessage")if d.message_type~=xMidiMessage.TYPE.NOTE_ON and d.message_type~=xMidiMessage.TYPE.NOTE_OFF then return end;local e=self:get_voice_index(d)if e then if d.message_type==xMidiMessage.TYPE.NOTE_OFF then local f=self.voices[e]f.message_type=xMidiMessage.TYPE.NOTE_OFF;self:release(e)return f else LOG("*** xVoiceManager:input_message() - voice is already active")return false,e end end;if d.message_type==xMidiMessage.TYPE.NOTE_OFF then return end;if self.follow_track then d._originating_track_index=d.track_index end;if self.follow_instrument then d._originating_instrument_index=d.instrument_index end;if self.follow_octave then d._originating_octave=d.octave end;self:_register(d)return d,#self.voices end;function xVoiceManager:input_note_column(g,h,i)TRACE("xVoiceManager:input_note_column(xnotecol,col_idx,line_idx)",g,h,i)local j={g.note_value,g.volume_value}local k=g.instrument_value+1;local d=xMidiMessage{values=j,instrument_index=k,note_column_index=h,line_index=i}if g.note_value<renoise.PatternLine.NOTE_OFF then d.message_type=xMidiMessage.TYPE.NOTE_ON elseif g.note_value==renoise.PatternLine.NOTE_OFF then d.message_type=xMidiMessage.TYPE.NOTE_OFF else LOG("Nothing to do here...")d=nil end;if d then self:input_message(d)end end;function xVoiceManager:release_all()TRACE("xVoiceManager:release_all()")for c,l in ripairs(self.voices)do self:release(c)end end;function xVoiceManager:release_all_instrument(k)TRACE("xVoiceManager:release_all_instrument(instr_idx)",k)for c,l in ripairs(self.voices)do if l.instrument_index==k then self:release(c)end end end;function xVoiceManager:release_all_track(m)TRACE("xVoiceManager:release_all_track(track_idx)",m)for c,l in ripairs(self.voices)do if l.track_index==m then self:release(c)end end end;function xVoiceManager:release(e)TRACE("xVoiceManager:release(voice_idx)",e)self.released_index=e;self.released_observable:bang()table.remove(self.voices,e)self.voices_observable:remove(e)end;function xVoiceManager:get_voice_index(d)TRACE("xVoiceManager:get_voice_index(xmsg)",d)if d.message_type and(d.message_type~=xMidiMessage.TYPE.NOTE_ON and d.message_type~=xMidiMessage.TYPE.NOTE_OFF and d.message_type~=xMidiMessage.TYPE.KEY_AFTERTOUCH)then LOG("*** xVoiceManager:input_message() - only MIDI notes and key-aftertouch are accepted")return end;local n=d.values[1]local o=nil;local p=nil;local q=nil;if d.message_type==xMidiMessage.TYPE.NOTE_OFF then for c,l in ipairs(self.voices)do if l.values[1]==n then if not o and self.follow_instrument and l._originating_instrument_index then o=l._originating_instrument_index end;if not p and self.follow_track and l._originating_track_index then p=l._originating_track_index end;if not q and self.follow_octave and l._originating_octave then q=l._originating_octave end end end end;for c,l in ipairs(self.voices)do if l.values[1]==n then if d.channel and l.channel==d.channel and d.octave and(l.octave==d.octave or q and l.octave==q)and d.track_index and(l.track_index==d.track_index or p and l.track_index==p)and d.instrument_index and(l.instrument_index==d.instrument_index or o and l.instrument_index==o)then l.octave=q or l.octave;l.track_index=p or l.track_index;l.instrument_index=o or l.instrument_index;return c end end end end;function xVoiceManager:get_available_columns(m)TRACE("xVoiceManager:get_available_columns(track_idx)",m)local r={true,true,true,true,true,true,true,true,true,true,true,true}for c,l in ipairs(self.voices)do if l.track_index==m then r[l.note_column_index]=false end end;return r end;function xVoiceManager:_steal_voice()TRACE("xVoiceManager:_steal_voice()")if#self.voices<0 then LOG("No active voice, nothing to steal...")return end;self.stolen_index=1;self.stolen_observable:bang()self:release(self.stolen_index)end;function xVoiceManager:_attach_to_song()TRACE("xVoiceManager:_attach_to_song()")rns.instruments_observable:add_notifier(function(s)TRACE("xVoiceManager: instruments_observable fired...",s)if s.type=="remove"then self:release_all_instrument(s.index)elseif s.type=="insert"then for c,l in ipairs(self.voices)do if l.track_index>=s.index then l.track_index=l.track_index+1 end end end end)rns.tracks_observable:add_notifier(function(s)TRACE("xVoiceManager: tracks_observable fired...",s)if s.type=="remove"then self:release_all_track(s.index)elseif s.type=="insert"then for c,l in ipairs(self.voices)do if l.track_index>=s.index then l.track_index=l.track_index+1 end end end end)end;function xVoiceManager:get_by_pitch(t)TRACE("xVoiceManager:get_by_pitch(pitch)",t)for c,l in ipairs(self.voices)do if l.values[1]==t then return l,c end end end;function xVoiceManager:get_higher(u)TRACE("xVoiceManager:get_higher(idx)",u)local v=self.voices[u]if not v then return end;local w=v.values[1]local t=nil;for c,l in ipairs(self.voices)do if l.values[1]>w then if not t then t=l.values[1]end;t=math.min(t,l.values[1])end end;if t then return self:get_by_pitch(t)end end;function xVoiceManager:get_highest()TRACE("xVoiceManager:get_highest()")local x,u;local t=0;for c,l in ipairs(self.voices)do if l.values[1]>t then x=l;t=l.values[1]u=c end end;return x,u end;function xVoiceManager:get_lower(u)TRACE("xVoiceManager:get_lower(idx)",u)local v=self.voices[u]if not v then return end;local w=v.values[1]local t=nil;for c,l in ipairs(self.voices)do if l.values[1]<w then if not t then t=l.values[1]end;t=math.max(t,l.values[1])end end;if t then return self:get_by_pitch(t)end end;function xVoiceManager:get_lowest()TRACE("xVoiceManager:get_lowest()")local x,u;local t=cLib.HUGE_INT;for c,l in ipairs(self.voices)do if l.values[1]<t then x=l;t=l.values[1]u=c end end;return x,u end;function xVoiceManager:_register(d)TRACE("xVoiceManager:_register(xmsg)",d)if self.voice_limit>0 and#self.voices==self.voice_limit then LOG("Steal the oldest voice and re-use that column")local y=self.voices[1].note_column_index;self:_steal_voice()d.note_column_index=y elseif self.column_allocation then local z=self:get_available_columns(d.track_index)if not table.is_empty(z)then local A=d.note_column_index and z[d.note_column_index]or false;if A then else for c=d.note_column_index,12 do if z[c]then d.note_column_index=c;break end end end else LOG("No more note columns available, using the last one")self:_steal_voice()d.note_column_index=12 end end;table.insert(self.voices,d)self.voices_observable:insert(#self.voices)self.triggered_index=#self.voices;self.triggered_observable:bang()if self.duration>0 then local B=renoise.tool().app_idle_observable;if not B:has_notifier(self,xVoiceManager._check_expired)then renoise.tool().app_idle_observable:add_notifier(self,xVoiceManager._check_expired)end end end;function xVoiceManager:_check_expired()TRACE("xVoiceManager:_check_expired()")for c,l in ripairs(self.voices)do local C=os.clock()-l.timestamp;if C>self.duration then self:release(c)end end;if#self.voices==0 then local B=renoise.tool().app_idle_observable;if B:has_notifier(self,xVoiceManager._check_expired)then renoise.tool().app_idle_observable:remove_notifier(self,xVoiceManager._check_expired)end end end