cLib.require(_clibroot.."cDocument")cLib.require(_clibroot..'cFilesystem')cLib.require(_xlibroot.."xNoteColumn")cLib.require(_xlibroot.."xSongPos")cLib.require(_xlibroot.."xTrack")cLib.require(_xlibroot.."xPatternSelection")class'xPhrase'(cDocument)xPhrase.KEY_TRACKING={NONE=1,TRANSPOSE=2,OFFSET=3}xPhrase.ERROR={MISSING_INSTRUMENT=1,MISSING_PHRASE=2,FILE_EXISTS=3}xPhrase.DOC_PROPS={{name="name",title="Name",value_default=""},{name="number_of_lines",title="Number of lines",value_default=32,value_min=1,value_max=512,value_quantum=1},{name="visible_note_columns",title="Visible note-columns",value_min=1,value_max=12,value_quantum=1,value_default=4},{name="visible_effect_columns",title="Visible effect-columns",value_min=0,value_max=8,value_quantum=1,value_default=1},{name="key_tracking",title="Key-tracking",value_min=xPhrase.KEY_TRACKING.NONE,value_max=xPhrase.KEY_TRACKING.OFFSET,value_quantum=1,value_default=xPhrase.KEY_TRACKING.TRANSPOSE,value_enums={"None","Transpose","Offset"}},{name="base_note",title="Base-note",value_min=0,value_max=119,value_quantum=1,value_default=48,value_tostring=function(a)return xNoteColumn.note_value_to_string(a)end,value_tonumber=function(a)return xNoteColumn.note_string_to_value(a)end},{name="looping",title="Looping",value_default=true},{name="loop_start",title="Loop-start",value_min=0,value_max=511,value_quantum=1,value_default=0,zero_based=true},{name="loop_end",title="Loop-end",value_min=1,value_max=512,value_quantum=1,value_default=32,zero_based=true},{name="autoseek",title="Autoseek",value_default=true},{name="lpb",title="LPB",value_min=1,value_max=256,value_quantum=1,value_default=4},{name="shuffle",title="Shuffle",value_min=0,value_max=1,value_default=0.0,value_tostring=function(a)return("%.0f %%"):format(a*100)end,value_tonumber=function(a)return tonumber(string.match(a,"%d*"))/100 end,value_factor=100},{name="instrument_column_visible",title="Instrument-column visible",value_default=true},{name="volume_column_visible",title="Volume-column visible",value_default=false},{name="panning_column_visible",title="Panning-column visible",value_default=false},{name="delay_column_visible",title="Delay-column visible",value_default=false},{name="sample_effects_column_visible",title="Sample-effects-column visible",value_default=true}}function xPhrase.replace_sample_index(b,c,d)TRACE("xLib.replace_sample_index(phrase,idx_from,idx_to)",b,c,d)if not b.instrument_column_visible then return end;c=c-1;d=d-1;local e=b:lines_in_range(1,b.number_of_lines)for f,g in ipairs(e)do for h,i in ipairs(g.note_columns)do if h<=b.visible_note_columns then if i.instrument_value==c then i.instrument_value=d end end end end end;function xPhrase.get_line_from_cursor(b,j,k,l,m)TRACE("xPhrase.get_line_from_cursor(phrase,trigger_pos,cursor_pos,line_offset,notecol)",b,j,k,l,m)assert(type(b),"InstrumentPhrase")assert(type(j),"xCursorPos")l=l and l or 0;local n=xSongPos.get_line_diff(j,k)local o=b.lpb;local p=o/rns.transport.lpb;local q=l+n*p;local r=cLib.fraction(q)q=math.floor(q)+1;local s=nil;if not m then local t,u,v,w,x=j:resolve()if not v then return nil,"Could not resolve track"end;if v.delay_column_visible then if not x then return nil,"Could not resolve pattern-line"end;m=x.note_columns[j.column]end end;if not m then return nil,"Could not resolve note-column"end;s=m.delay_value;if s and s>0 then local n=p*s/255;q=q-n end;if not b.looping then if q>b.number_of_lines then return nil,"Can't slice phrase after the last line has been reached"end else if q>=b.loop_end then local y=b.loop_end-b.loop_start;q=q%y;if q==b.loop_end then q=b.loop_start end;q=q+b.loop_start-1 end end;if q==0 then q=b.number_of_lines end;return q+r end;function xPhrase.note_is_keymapped(z,A)TRACE("xPhrase.note_is_keymapped(note,instr)",z,A)for B,C in ipairs(A.phrase_mappings)do if xSampleMapping.within_note_range(z,C)then return true end end;return false end;function xPhrase.clear_foreign_commands(b)TRACE("xPhrase.clear_foreign_commands(phrase)",b)if b.is_empty then return end;local D={"0Z","ZT","ZL","ZK","ZG","ZB","ZD"}for B,C in ipairs(b.lines)do if b.sample_effects_column_visible then for E,i in ipairs(C.note_columns)do if table.find(D,i.effect_number_string)then i.effect_number_string="00"i.effect_amount_string="00"end end end;for F,G in ipairs(C.effect_columns)do if F>b.visible_effect_columns then break elseif table.find(D,G.number_string)then G.number_string="00"G.amount_string="00"end end end end;function xPhrase.stringify(b)TRACE("xPhrase.stringify",b)if b.is_empty then return""end;local H={}for B,C in ipairs(b.lines)do table.insert(H,tostring(C))end;return table.concat(H,"\n")end;function xPhrase.apply_to_track(I)TRACE("xPhrase.apply_to_track(options)",I)assert(type(I)=="table")assert(type(I.instr_index)=="number")assert(type(I.phrase)=="InstrumentPhrase")assert(type(I.sequence_index)=="number")assert(type(I.track_index)=="number")assert(type(I.anchor_to_selection)=="boolean")assert(type(I.cont_paste)=="boolean")assert(type(I.skip_muted)=="boolean")assert(type(I.expand_columns)=="boolean")assert(type(I.expand_subcolumns)=="boolean")assert(type(I.insert_zxx)=="boolean")assert(type(I.mix_paste)=="boolean")local v=rns.tracks[I.track_index]if not v then return false,"The track doesn't exist"end;local w=xTrack:get_pattern_track(I.sequence_index,I.track_index)if v.type~=renoise.Track.TRACK_TYPE_SEQUENCER then return false,"Can only write to sequencer-tracks"end;local J=I.selection and true or false;local K=I.selection;local L,M;local N,O;if not K then K=xPatternSelection.get_pattern_track(I.sequence_index,I.track_index)if I.expand_columns then local P=I.phrase.visible_note_columns+I.phrase.visible_effect_columns;K.end_column=K.start_column+P-1 end end;if K.start_column<=v.visible_note_columns then L=K.start_column;N=1 else L=nil;N=K.start_column-v.visible_note_columns end;if K.end_column<=v.visible_note_columns then N=nil;M=K.end_column else M=K.start_column+I.phrase.visible_note_columns-1;O=K.end_column-(v.visible_note_columns+(L and 1 or 0))end;local Q=K.end_line-K.start_line+1;local R=I.phrase.number_of_lines;local S=I.phrase.looping and(I.phrase.loop_start>1 or I.phrase.loop_end-1<I.phrase.number_of_lines)for T=1,Q do local U=T;local V=function(W)if S then if W<I.phrase.loop_end then return W else local X=I.phrase.loop_end-I.phrase.loop_start;local H=(W-I.phrase.loop_start)%X;H=H+I.phrase.loop_start;return H end else return W%R end end;if not I.cont_paste then if T>R then break end else if I.anchor_to_selection then U=V(T)else U=V(K.start_line+T-1)end;if U==0 then U=R end end;local Y=I.phrase:line(U)local Z=w:line(K.start_line+T-1)local _=v.visible_note_columns;local a0=v.visible_effect_columns;local function a1(a2)return I.anchor_to_selection and N or 1 end;local function a3(a2)return not I.anchor_to_selection and a2-1 or 0 end;local a4=false;if L then local a5=0;local a6=a1(L)local a7=a3(L)for a2=a6,renoise.InstrumentPhrase.MAX_NUMBER_OF_NOTE_COLUMNS do if a2>=L and a2<=M then a5=a5+1;local a8=I.phrase:column_is_muted(a5)and I.skip_muted or false;if not a8 then local a9=Z:note_column(a2)local aa=a5+a7;local ab=Y:note_column(aa)if ab.note_value<121 then a9.note_value=ab.note_value elseif not I.mix_paste then a9.note_value=121 end;if ab.note_value<121 then a9.instrument_value=I.instr_index-1 elseif not I.mix_paste then a9.note_value=121 end;if a9.note_value<121 then a4=true end;if I.phrase.volume_column_visible then if ab.volume_value~=255 then a9.volume_value=ab.volume_value;if I.expand_subcolumns then v.volume_column_visible=true end elseif not I.mix_paste then a9.volume_value=255 end end;if I.phrase.panning_column_visible then if ab.panning_value~=255 then a9.panning_value=ab.panning_value;if I.expand_subcolumns then v.panning_column_visible=true end elseif not I.mix_paste then a9.panning_value=255 end end;if I.phrase.delay_column_visible then if ab.delay_value>0 then a9.delay_value=ab.delay_value;if I.expand_subcolumns then v.delay_column_visible=true end elseif not I.mix_paste then a9.delay_value=0 end end;if I.phrase.sample_effects_column_visible then if ab.effect_amount_value>0 then a9.effect_amount_value=ab.effect_amount_value;if I.expand_subcolumns then v.sample_effects_column_visible=true end elseif not I.mix_paste then a9.effect_amount_value=0 end;if ab.effect_number_value>0 then a9.effect_number_value=ab.effect_number_value;if I.expand_subcolumns then v.sample_effects_column_visible=true end elseif not I.mix_paste then a9.effect_number_value=0 end end;_=math.max(a2,_)else if not I.mix_paste then local a9=Z:note_column(a2)a9:clear()end end end end end;if N then local a5=1;local a6=a1(N)local a7=a3(N)for a2=a6,renoise.InstrumentPhrase.MAX_NUMBER_OF_EFFECT_COLUMNS do if a2>=N and a2<=O then local a9=Z:effect_column(a2)local aa=a5+a7;local ab=Y:effect_column(a5+a7)if ab.amount_value>0 then a9.amount_value=ab.amount_value elseif not I.mix_paste then a9.amount_value=0 end;if ab.number_value>0 then a9.number_value=ab.number_value elseif not I.mix_paste then a9.number_value=0 end;a5=a5+1;a0=math.max(a2,a0)end end end;local a2=N and N+1 or 1;local a9=Z:effect_column(a2)if a9 and I.insert_zxx and a4 then if a2<=renoise.InstrumentPhrase.MAX_NUMBER_OF_EFFECT_COLUMNS then a0=math.max(a2,a0)a9.number_string="0Z"a9.amount_value=00 end end;if I.expand_columns then v.visible_note_columns=_;v.visible_effect_columns=a0 end end;return true end;function xPhrase.export_preset(ac,ad,ae,af,ag)TRACE("xPhrase.export_preset(folder,instr_idx,phrase_idx,overwrite,prefix)",ac,ad,ae,af,ag)local A=rns.instruments[ad]if not A then return false,xPhrase.ERROR.MISSING_INSTRUMENT end;local b=A.phrases[ae]if not b then return false,xPhrase.ERROR.MISSING_PHRASE end;if not io.exists(ac)then local H,ah=cFilesystem.makedir(ac)if ah then return false,ah end end;local ai=xPhrase.get_preset_filepath(ac,b,ag and ae)if not af and io.exists(ai)then return false,xPhrase.ERROR.FILE_EXISTS end;renoise.app():save_instrument_phrase(ai)end;function xPhrase.get_preset_filepath(ac,b,ae)TRACE("xPhrase.get_preset_filepath(folder,phrase,phrase_idx)",ac,b,ae)local ai=nil;local aj=cFilesystem.sanitize_filename(b.name)if ae then ai=("%s%.2d_%.2X_%s.xrnz"):format(ac,ae,ae,aj)else ai=("%s%s.xrnz"):format(ac,aj)end;return ai end;function xPhrase.get_raw_preset_name(ak)TRACE("xPhrase.get_raw_preset_name(str)",ak)local ak=cFilesystem.get_raw_filename(ak)local al=string.match(ak,"%d%d_%x%x_(.*)")return al or ak end;function xPhrase.set_property(b,am,a)TRACE("xPhrase.set_property(phrase,key,val)",b,am,a)local an=cDocument.get_property(xPhrase.DOC_PROPS,am)if not an then error("Could not apply value, missing from DOC_PROPS")end;if am=="loop_start"then if a>b.number_of_lines then a=b.number_of_lines end end;if am=="loop_end"then if a>b.number_of_lines then a=b.number_of_lines end end;return cDocument.apply_value(b,an,a)end